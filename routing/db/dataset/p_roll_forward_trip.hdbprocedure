PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_roll_forward_trip" (
	IN from_time TIMESTAMP,  -- from_time required in UTC time
	IN to_time TIMESTAMP,  -- to_time required in UTC time
	IN path_id BIGINT,
	--IN rule_num TABLE(rule_number SMALLINT)
	OUT return_code INTEGER,
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   AS
BEGIN
	/*********************************************************************
	This procedure tries to recalculate the trip generated by departure rules.
	Both from_time and to_time should move forward comparing to the original from_time, to_time.

	For each rule number, the set of trips will be recalculated.
	*********************************************************************/
	-- decl_list
	DECLARE CURSOR rule_num_csr FOR 
	SELECT rule_number
	FROM "sap.tm.trp.routing.db.dataset::t_path_departure_rule"
	WHERE path_id = :path_id;
	-- exception_list
	-- stmt_list

	return_code = 0;
	
	-- Check time range
	IF :from_time IS NULL OR :to_time IS NULL OR :from_time >= :to_time THEN
	    return_code = 1;
    	msg_param = SELECT 0 AS placeholder, TO_NVARCHAR(:from_time) AS VALUE FROM DUMMY
	    UNION ALL
	    SELECT 1 AS placeholder, TO_NVARCHAR(:to_time) AS VALUE FROM DUMMY;
	    
        CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_TIME_RANGE_INVALID', 
        :msg_param, 'E', :message);
        
        log = SELECT * FROM :message;
        RETURN;
	END IF;

	-- For each rule number
	FOR rule_num_row AS rule_num_csr DO 
		DECLARE min_departure_time, max_departure_time SECONDDATE;
		DECLARE cycle_type CHAR;
		DECLARE pattern VARCHAR(100);
		DECLARE fix_time TIME;
		DECLARE new_from_time SECONDDATE;
		-- Fetch the minimum departure time and maximum departure time from the trip table
		-- In case there are no trip data, just try to generate trip from from_time to to_time
		-- here just set to any time before from_time is OK, pretend there is trip generated in the past
		SELECT IFNULL(MIN(departure_time),ADD_SECONDS(:from_time, -1)), IFNULL(MAX(departure_time), ADD_SECONDS(:from_time, -1))
		INTO min_departure_time, max_departure_time
		FROM "sap.tm.trp.routing.db.dataset::t_trip"
		WHERE path_id = :path_id AND rule_number = rule_num_row.rule_number;
		
		-- To roll forward, the input from_time should at least larger than the minimum departure time of already generated trip
		IF :from_time <= :min_departure_time THEN
		    CONTINUE;
		END IF;
		
		-- Fetch departure rule related to the given path_id and rule_num
		SELECT cycle_type, pattern, departure_time time INTO cycle_type, pattern, fix_time
		FROM "sap.tm.trp.routing.db.dataset::t_path_departure_rule"
		WHERE path_id = :path_id AND rule_number = rule_num_row.rule_number;

		-- Remove trips whose departure time is less than :from_time
		del_ids = 
		SELECT id
		FROM "sap.tm.trp.routing.db.dataset::t_trip"
		WHERE path_id = :path_id AND rule_number = rule_num_row.rule_number AND departure_time < :from_time;

		DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip_sequence"
		WHERE EXISTS(SELECT id FROM :del_ids WHERE id = trip_id);
		DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip" AS A
		WHERE EXISTS(SELECT id FROM :del_ids WHERE id = A.id);
		-- Generate trips start from the time of maximum of :from_time and max_departure_time`
		-- Because max_departure_time has been computed last time, so need to exclude it
		SELECT CASE
		WHEN :from_time > ADD_SECONDS(:max_departure_time, 1) THEN :from_time
		ELSE ADD_SECONDS(:max_departure_time, 1)
		END INTO new_from_time
		FROM DUMMY;
		
		-- In case new_from_time is larger than or equal to to_time, then that it means it has already been generated
		IF :new_from_time >= :to_time THEN
		    CONTINUE;
		END IF;

		rule_tbl = 
		SELECT rule_num_row.rule_number AS rule_number
		FROM DUMMY;
		
		CALL "sap.tm.trp.routing.db.dataset::p_generate_trip" 
		(:new_from_time, :to_time, :path_id, :rule_tbl, return_code, message_tmp, log_tmp);
		
		message = 
		SELECT * FROM :message
		UNION ALL
		SELECT * FROM :message_tmp;
		
		log = 
		SELECT * FROM :log
		UNION ALL
		SELECT * FROM :log_tmp;
	END FOR;
END