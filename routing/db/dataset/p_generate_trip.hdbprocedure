procedure "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_generate_trip" (
	IN from_time TIMESTAMP, -- The from_time required in UTC time!!!
	IN to_time TIMESTAMP,  -- The to_time required in UTC time!!!
	IN path_id BIGINT,
	IN rule_numbers "sap.tm.trp.routing.db.dataset::tt_rule_number",
	--OUT trip TABLE(id BIGINT, path_id BIGINT, rule_number SMALLINT, from_location VARCHAR(50), to_location VARCHAR(50), departure_time SECONDDATE, arrival_time SECONDDATE),
	--OUT trip_sequence TABLE(trip_id BIGINT, sequence INTEGER, location VARCHAR(50), departure_time SECONDDATE, arrival_time SECONDDATE)
    OUT return_code INTEGER,
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log "sap.tm.trp.routing.db.common::tt_message"
)
language sqlscript
sql security invoker
default schema "SAP_TM_ROUTING"
as
begin

	DECLARE CURSOR rule_csr FOR SELECT rule_number FROM :rule_numbers;
	DECLARE departure_tbl TABLE(rule_number SMALLINT, departure_time TIMESTAMP);
	DECLARE from_date, to_date DATE;
	DECLARE count INTEGER;
	DECLARE DAILY_CYCLE CONSTANT CHAR = 'D';
	DECLARE WEEK_CYCLE CONSTANT CHAR = 'W';
	DECLARE MONTH_CYCLE CONSTANT CHAR = 'M';

	-- Check time range
	IF :from_time IS NULL OR :to_time IS NULL OR :from_time >= :to_time THEN
	    return_code = 1;
    	msg_param = SELECT 0 AS placeholder, TO_NVARCHAR(:from_time) AS VALUE FROM DUMMY
	    UNION ALL
	    SELECT 1 AS placeholder, TO_NVARCHAR(:to_time) AS VALUE FROM DUMMY;

        CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_TIME_RANGE_INVALID',
        :msg_param, 'E', :message);

        log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
        RETURN;
	END IF;

	-- Generate trip for all the rules if no one is specified
	SELECT COUNT(*) INTO count FROM :rule_numbers;

	IF :count = 0 THEN
	    rule_numbers = SELECT rule_number
	    FROM "sap.tm.trp.routing.db.dataset::t_path_departure_rule"
		WHERE path_id = :path_id;
	END IF;

	-- Initialize trip, trip_sequence to empty array
	trip =
	SELECT 0 AS id, 0 AS path_id, 0 AS rule_number, '' AS from_location, '' AS to_location, TO_TIMESTAMP('') AS departure_time,
	TO_TIMESTAMP('') AS arrival_time
	FROM DUMMY WHERE 1 <> 1;

	trip_sequence =
	SELECT 0 AS trip_id, 0 AS sequence, '' AS location, TO_TIMESTAMP('') AS departure_time, TO_TIMESTAMP('') AS arrival_time
	FROM DUMMY WHERE 1 <> 1;

	-- For each rule number, generate a list of departure times between from_time and to_time
	FOR rule_row AS rule_csr DO
		DECLARE cur_cycle_type CHAR;
		DECLARE cur_pattern VARCHAR(100);
		DECLARE cur_time TIME;
		DECLARE cur_timezone NVARCHAR(40);
		--DECLARE departure_arr SECONDDATE ARRAY; -- contain the departure datetime for current rule
		--DECLARE departure_arr_len INTEGER = 0;
		DECLARE pattern_arr TINYINT ARRAY; -- contain the pattern array for cur_pattern
		DECLARE pattern_arr_len INTEGER = 0;

		DECLARE is_cycle_wrap CHAR;  -- indicate whether the pattern cycle has been wrapped
		DECLARE next_pattern_idx INTEGER; -- the pattern_arr index which point to the entry to consider for the next possible departure date

		DECLARE cur_date DATE; -- current date as a start to judge the next possible departure time
		DECLARE cur_datetime SECONDDATE; -- current datetime
		DECLARE local_from_time, local_to_time SECONDDATE; -- from time and to time at local zone

		DECLARE return_code INTEGER;

		-- Fetch cur_cycle, cur_pattern, cur_time
		SELECT cycle_type, pattern, departure_time, timezone INTO cur_cycle_type, cur_pattern, cur_time, cur_timezone
		FROM "sap.tm.trp.routing.db.dataset::t_path_departure_rule"
		WHERE path_id = :path_id AND rule_number = rule_row.rule_number;

        -- Convert UTC time to departure rule configured time zone
        SELECT UTCTOLOCAL(:from_time, IFNULL(:cur_timezone, 'UTC'), 'platform'),
               UTCTOLOCAL(:to_time, IFNULL(:cur_timezone, 'UTC') ,'platform')
          INTO local_from_time,
               local_to_time
          FROM DUMMY;
        SELECT TO_DATE(:local_from_time), TO_DATE(:local_to_time) INTO from_date, to_date FROM DUMMY;

		-- Generate pattern array for pattern
		-- Assume pattern always has the format like 1,2,3,4  In increasing order, separated by ','
		IF :cur_cycle_type != :DAILY_CYCLE THEN
			DECLARE start_pos INTEGER = 1;
			DECLARE pattern_length INTEGER;
			DECLARE str_digits VARCHAR(10);
			DECLARE digits_len INTEGER;
			DECLARE day_digits TINYINT;

			SELECT LENGTH(:cur_pattern) INTO pattern_length FROM DUMMY;

			WHILE :start_pos <= :pattern_length DO
				SELECT SUBSTR_REGEXPR('([[:digit:]]+),?' IN :cur_pattern FROM :start_pos GROUP 1) INTO str_digits
				FROM DUMMY;
				SELECT LENGTH(:str_digits) INTO digits_len
				FROM DUMMY;
				SELECT TO_TINYINT(:str_digits) INTO day_digits
				FROM DUMMY;
				-- append to pattern_arr array
				pattern_arr_len = :pattern_arr_len + 1;
				pattern_arr[:pattern_arr_len] = :day_digits;

				start_pos = :start_pos + :digits_len + 1;
			END WHILE;
		ELSE
			-- For daily cycle, pattern_arr always contain one entry with value 1
			pattern_arr_len = 1;
			pattern_arr[1] = 1;
		END IF;

		--Try to generate first possible departure time according to cur_cycle, cur_pattern, cur_time
		-- First decide the possible start date
		cur_date = :from_date;
		SELECT TO_SECONDDATE(TO_VARCHAR(:cur_date, 'YYYY-MM-DD') || ' ' || TO_VARCHAR(:cur_time, 'HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS') INTO cur_datetime
		FROM DUMMY;
		IF :cur_datetime >= :local_from_time THEN
			SELECT ADD_DAYS(:cur_date, -1) INTO cur_date
			FROM DUMMY;
		END IF;

		-- find the next pattern index which point to the next departure day
		IF :cur_cycle_type = :MONTH_CYCLE THEN
			DECLARE pattern_iter INTEGER;
			DECLARE cur_monthday TINYINT;
			SELECT DAYOFMONTH(:cur_date) INTO cur_monthday
			FROM DUMMY;
			next_pattern_idx = 0;
			FOR pattern_iter IN 1..:pattern_arr_len DO
				IF :pattern_arr[:pattern_iter] > :cur_monthday THEN
					is_cycle_wrap = '';
					next_pattern_idx = :pattern_iter;
					BREAK;
				END IF;
			END FOR;
			IF :next_pattern_idx = 0 THEN
				is_cycle_wrap = 'X';
				next_pattern_idx = 1;
			END IF;
		ELSEIF :cur_cycle_type = :WEEK_CYCLE THEN
			DECLARE pattern_iter INTEGER;
			DECLARE cur_weekday TINYINT;
			SELECT WEEKDAY(:cur_date) INTO cur_weekday
			FROM DUMMY;
			next_pattern_idx = 0;
			FOR pattern_iter IN 1..:pattern_arr_len DO
				IF :pattern_arr[:pattern_iter] > :cur_weekday THEN
					is_cycle_wrap = '';
					next_pattern_idx = :pattern_iter;
					BREAK;
				END IF;
			END FOR;
			IF :next_pattern_idx = 0 THEN
				is_cycle_wrap = 'X';
				next_pattern_idx = 1;
			END IF;
		ELSE
			-- For daily cycle, always cycle wrap and set next_pattern_idx to 1
			is_cycle_wrap = 'X';
			next_pattern_idx = 1;
		END IF;

		-- find all possible departure time
		LOOP
			-- compute the next possible available departure date
			DECLARE next_cycle_day TINYINT = :pattern_arr[:next_pattern_idx];
			DECLARE trip_id BIGINT;

			CALL "sap.tm.trp.routing.db.dataset::p_compute_next_departure_time"(:cur_date, :cur_time, :cur_cycle_type, :is_cycle_wrap, :next_cycle_day, return_code, cur_datetime);

			IF :cur_datetime > :local_to_time THEN
				BREAK;
			END IF;

			SELECT :cur_datetime INTO cur_date
			FROM DUMMY;

			IF :cur_cycle_type != :DAILY_CYCLE THEN
				IF :next_pattern_idx = :pattern_arr_len THEN
					is_cycle_wrap = 'X';
					next_pattern_idx = 1;
				ELSE
					is_cycle_wrap = '';
					next_pattern_idx = :next_pattern_idx + 1;
				END IF;
			END IF;

			-- if not succeed due to the fact that cycle type is month and current month has no such day as 29th, 30th, or 31th
			IF :return_code != 0 THEN
				CONTINUE;
			END IF;

			-- store the departure time
			--departure_arr_len = :departure_arr_len + 1;
			--departure_arr[:departure_arr_len] = :cur_datetime;

			CALL "sap.tm.trp.routing.db.dataset::p_generate_trip_by_departure_time"(:path_id, :cur_datetime, trip_tmp, trip_conn_tmp);

			SELECT "sap.tm.trp.routing.db.dataset::s_trip".NEXTVAL INTO trip_id
			FROM DUMMY;

			trip =
			SELECT * FROM :trip
			UNION ALL
			SELECT :trip_id AS id, :path_id AS path_id, rule_row.rule_number AS rule_number, from_location, to_location, LOCALTOUTC(departure_time, :cur_timezone,'platform'), LOCALTOUTC(arrival_time, :cur_timezone,'platform')
			FROM :trip_tmp;

			trip_sequence =
			SELECT * FROM :trip_sequence
			UNION ALL
			SELECT :trip_id AS trip_id, sequence, location, LOCALTOUTC(departure_time, :cur_timezone,'platform'), LOCALTOUTC(arrival_time, :cur_timezone,'platform')
			FROM :trip_conn_tmp;
		END LOOP;
	END FOR;

	-- Delete existing trips
	-- Use roll-forward if some old trip needs to be kept
	trip_id_tab = SELECT o.id
	FROM "sap.tm.trp.routing.db.dataset::t_trip" AS o
	INNER JOIN :trip as n
	ON o.path_id = n.path_id
	AND o.rule_number = n.rule_number
	AND o.departure_time = n.departure_time;

	DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip_sequence"
	WHERE trip_id IN (SELECT id FROM :trip_id_tab);

	DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip"
	WHERE id IN (SELECT id FROM :trip_id_tab);

	-- insert trip and trip_sequence into database
	INSERT INTO "sap.tm.trp.routing.db.dataset::t_trip" ( id, path_id, rule_number, from_location, to_location, departure_time, arrival_time, created_by, created_on, changed_by, changed_on )
	SELECT id, path_id, rule_number, from_location, to_location, departure_time, arrival_time, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
	FROM :trip;

	INSERT INTO "sap.tm.trp.routing.db.dataset::t_trip_sequence" (trip_id, sequence, location, departure_time, arrival_time)
	SELECT trip_id, sequence, location, departure_time, arrival_time
	FROM :trip_sequence;

	return_code = 0;
	message = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
    log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;

end;