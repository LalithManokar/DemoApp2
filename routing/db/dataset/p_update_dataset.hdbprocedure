PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_update_dataset" (
    IN dataset_id BIGINT,
    IN from_date DATE,
    IN to_date DATE,
    IN locations "sap.tm.trp.routing.db.common::tt_location_id",
    IN connection_list "sap.tm.trp.routing.db.dataset::tt_connection",
    IN connection_carrier "sap.tm.trp.routing.db.dataset::tt_connection_carrier", 
	IN paths "sap.tm.trp.routing.db.dataset::tt_path_external",
	IN path_connection "sap.tm.trp.routing.db.dataset::tt_path_connection",
	OUT return_code TINYINT,
	OUT message "sap.tm.trp.routing.db.common::tt_message"
	) 
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS
BEGIN
   /*************************************
       Write your procedure logic 
   *************************************/
	DECLARE msg_param TABLE(placeholder INTEGER, value NVARCHAR(100));
	DECLARE count INTEGER;
	DECLARE SOURCE_SYSTEM CHAR(1) = 'S';
	
	return_code = 0;
	message = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
	log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
	
	-- From date must not be later than to date
	IF :from_date > :to_date THEN
	    return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, '' AS VALUE FROM DUMMY WHERE 1 <> 1;
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_DATE_RANGE_INVALID', :msg_param, 'E', :message);
        return;
	END IF;
	
	CALL "sap.tm.trp.routing.db.dataset::p_validate_location_list"(
	    :locations, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Aggregate connection by from location, to location and mtr
    -- So the combination is unique in the dataset
    connection_aggregated = SELECT ROW_NUMBER() OVER () AS id, from_location, to_location, mtr,
    distance, duration
    FROM (SELECT from_location, to_location, mtr, AVG(distance) AS distance, AVG(duration) AS duration
    FROM :connection_list
    GROUP BY from_location, to_location, mtr);
    
    connection_carrier_aggregated = SELECT DISTINCT a.id AS connection_id, carrier
    FROM :connection_list AS m
    INNER JOIN :connection_carrier AS c
    ON m.id = c.connection_id
    INNER JOIn :connection_aggregated AS a
    ON a.from_location  = m.from_location
    AND a.to_location = m.to_location
    AND a.mtr = m.mtr;
	
	-- Validate connection
	CALL "sap.tm.trp.routing.db.dataset::p_validate_connection"(
	    :connection_aggregated, :connection_carrier_aggregated, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Use type + name to identify external single-stage path
	-- ID is too technical
	paths_to_validated = SELECT CASE WHEN name = '' OR NAME IS NULL THEN id ELSE CONCAT(type, name) END AS id,
	from_location, to_location, mtr, carrier
	FROM :paths;
	
	path_connection_to_validated = SELECT CASE WHEN p.name = '' OR p.NAME IS NULL THEN c.path_id ELSE SUBSTRING(CONCAT(p.type, p.name), 1, 50) END AS path_id,
	sequence, c.from_location, c.to_location, distance, duration, stay_time, cutoff_offset, availability_offset
	FROM :path_connection c
	LEFT OUTER JOIN :paths p
	ON c.path_id = p.id;
	
	CALL "sap.tm.trp.routing.db.dataset::p_validate_path"(
	    :paths_to_validated, :path_connection_to_validated, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
	
    -- Update location
    DELETE FROM "sap.tm.trp.routing.db.dataset::t_dataset_location"
    WHERE dataset_id = :dataset_id;
	
	INSERT INTO "sap.tm.trp.routing.db.dataset::t_dataset_location"
	(dataset_id, location_id)
	SELECT :dataset_id, location_id
	FROM :locations;
	
	SELECT COUNT(*) INTO count FROM :connection_aggregated;
	
	IF count > 0 THEN
	
    	-- Keep old connection id, created by and created on
    	connection_id_old = SELECT c2.id AS connection_id, c1.id as external_id,
    	c2.created_by, c2.created_on
    	FROM :connection_aggregated AS c1
    	LEFT OUTER JOIN 
    	(SELECT * FROM "sap.tm.trp.routing.db.dataset::t_connection" 
    	WHERE dataset_id = :dataset_id AND source = :SOURCE_SYSTEM) AS c2
    	ON c1.from_location = c2.from_location
    	AND c1.to_location = c2.to_location
    	AND c1.mtr = c2.mtr;
    	
    	-- Generate id for new connection
    	connection_id_map = SELECT 
    	"sap.tm.trp.routing.db.dataset::s_path".nextval	AS connection_id,
    	external_id,
    	SESSION_CONTEXT('APPLICATIONUSER') AS created_by,
    	CURRENT_UTCTIMESTAMP AS created_on
    	FROM :connection_id_old WHERE connection_id IS NULL;
    	
    	connection_id_map = SELECT * FROM :connection_id_map
    	UNION ALL 
    	SELECT connection_id, external_id,created_by, created_on
    	FROM :connection_id_old WHERE connection_id IS NOT NULL; 
    	
    	-- Delete system connection and their connection carrier
    	connection_id_tab = SELECT id AS connection_id
    	FROM "sap.tm.trp.routing.db.dataset::t_connection" 
    	WHERE dataset_id = :dataset_id AND source = :SOURCE_SYSTEM;
    	
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_connection_carrier" AS C
    	WHERE connection_id IN (SELECT connection_id FROM :connection_id_tab);
    	
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_connection"
    	WHERE id IN (SELECT connection_id AS id FROM :connection_id_tab);
    	
    	-- Compute hash
    	path_tmp = SELECT id, from_location, to_location, mtr, '' AS carrier
    	FROM :connection_aggregated;
    	
    	path_connection_tmp = SELECT id as path_id, 0 AS sequence, from_location, 
    	to_location, distance, duration, 0 as stay_time,
    	0 AS cutoff_offset, 0 AS availability_offset
    	FROM :connection_aggregated;
    	
    	CALL "sap.tm.trp.routing.db.dataset::p_calculate_path_hash"(
    	    :path_tmp, :path_connection_tmp, :path_hash
    	);
    	
    	-- Save updated connection or new connection
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_connection"
    	(id, dataset_id, from_location, to_location, mtr, distance, 
    	 duration, source, hash, created_by, created_on, changed_by, changed_on)
    	SELECT m.connection_id, :dataset_id as dataset_id, from_location, 
    	to_location, mtr, distance, duration, :SOURCE_SYSTEM, hash,
    	m.created_by, m.created_on, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
    	FROM :connection_aggregated as c INNER JOIN :connection_id_map as m
    	ON c.id = m.external_id
    	INNER JOIN :path_hash AS p
    	ON c.id = p.path_id;
    	
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_connection_carrier"
    	(connection_id, carrier)
    	SELECT m.connection_id as connection_id,c.carrier
    	FROM :connection_carrier_aggregated as c INNER JOIN :connection_id_map as m
    	ON c.connection_id = m.external_id;
	
	END IF;
	
	SELECT COUNT(*) INTO count FROM :paths;
	
	IF count > 0 THEN
	
    	-- Keep old path id, created by and created on
    	path_id_old = SELECT p2.id AS path_id, p1.id as external_id,
    	p2.created_by, p2.created_on
    	FROM :paths AS p1
    	LEFT OUTER JOIN (SELECT * FROM "sap.tm.trp.routing.db.dataset::t_path"
    	WHERE dataset_id = :dataset_id AND source = :SOURCE_SYSTEM )AS p2
    	ON p1.id = p2.external_id;
    	
    	-- Generate id for new paths
    	path_id_map = SELECT 
    	"sap.tm.trp.routing.db.dataset::s_path".nextval	AS path_id,
    	external_id, 
    	SESSION_CONTEXT('APPLICATIONUSER') AS created_by,
    	CURRENT_UTCTIMESTAMP AS created_on
    	FROM :path_id_old WHERE path_id IS NULL;
    	
    	path_id_map = SELECT * FROM :path_id_map
    	UNION ALL
    	SELECT * FROM :path_id_old WHERE path_id IS NOT NULL;
    	
    	-- Delete old system path
    	path_id_tab = SELECT id AS path_id FROM "sap.tm.trp.routing.db.dataset::t_path"
    	WHERE dataset_id = :dataset_id AND source = :SOURCE_SYSTEM;
    
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_path_connection"
    	WHERE path_id IN (SELECT path_id FROM :path_id_tab);
    
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_path"
    	WHERE dataset_id = :dataset_id AND source = :SOURCE_SYSTEM;
    	
    	path_temp = SELECT id, from_location, to_location, mtr, carrier
    	FROM :paths;
    	
    	-- Calculate hash
    	CALL "sap.tm.trp.routing.db.dataset::p_calculate_path_hash"(
    	    :path_temp, :path_connection, :path_hash
    	);
    	
    	tmp = select p.* from "sap.tm.trp.routing.db.dataset::t_path" AS p
    	INNER JOIN :path_id_map AS m
    	on p.id = m.path_id;
    	
    	-- Save updated paths and new paths
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path"
    	(id, name, external_id, external_type, dataset_id, from_location, to_location, mtr, carrier, source, hash,
    	 created_by, created_on, changed_by, changed_on)
    	SELECT m.path_id, p.name, m.external_id, p.type, :dataset_id as dataset_id, from_location, 
    	to_location, mtr, carrier, SOURCE_SYSTEM, h.hash,
    	m.created_by, m.created_on, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
    	FROM :path_id_map AS m INNER JOIN :paths AS p ON m.external_id = p.id
    	INNER JOIN :path_hash AS h
    	ON p.id = h.path_id;
    
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path_connection" (path_id, "SEQUENCE", 
    	from_location, to_location, distance, duration, stay_time, cutoff_offset, availability_offset)
    	SELECT A.path_id, sequence, from_location, to_location, distance, duration,
    	stay_time, cutoff_offset, availability_offset
    	FROM :path_id_map AS A INNER JOIN :path_connection AS B ON A.external_id = B.path_id;
	
	END IF;
	
	-- Update header
	UPDATE "sap.tm.trp.routing.db.dataset::t_dataset"
	SET valid_from = from_date, valid_to = :to_date,
	changed_by = SESSION_CONTEXT('APPLICATIONUSER'), changed_on = CURRENT_UTCTIMESTAMP,
	replicated_by = SESSION_CONTEXT('APPLICATIONUSER'), replicated_on = CURRENT_UTCTIMESTAMP
	WHERE id = :dataset_id; 
	
	CALL "sap.tm.trp.routing.db.path::p_invalidate_network_by_dataset" 
    (:dataset_id, '', :return_code, :message_tmp, :log_tmp);
    
    IF :return_code <> 0 THEN
        message = SELECT * FROM :message_tmp;
        log = SELECT * FROM :log_tmp;
        RETURN;
    END IF;
        
    message = SELECT * FROM :message 
    UNION ALL SELECT * FROM :message_tmp;
    log = SELECT * FROM :log 
    UNION ALL SELECT * FROM :log_tmp;
	
	return_code = 0;
END