PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_get_path_by_hash" (
    IN dataset_id BIGINT,
    IN filter "sap.tm.trp.routing.db.dataset::tt_hash",
    OUT paths TABLE (
        "PATH_ID" BIGINT,
        "EXTERNAL_ID" NVARCHAR(50),
        "FROM_LOCATION" NVARCHAR(50),
        "TO_LOCATION"NVARCHAR(50),
        "MTR" NVARCHAR(10),
        "CARRIER" NVARCHAR(50),
        "ACTION" CHAR,
        "HASH" VARBINARY(32)
    )
) 
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   READS SQL DATA AS
BEGIN
   /*************************************
       Write your procedure logic 
   *************************************/
	DECLARE count INTEGER;
	DECLARE CURSOR c_dataset(dataset "sap.tm.trp.routing.db.common::tt_id")
	FOR SELECT id FROM :dataset;
	DECLARE CURSOR c_path(path "sap.tm.trp.routing.db.dataset::tt_path_merge")
	FOR SELECT * FROM :path;
	
	DECLARE ACTION_CREATE CHAR = 'C';
	DECLARE ACTION_DELETE CHAR = 'D';
	DECLARE ACTION_UPDATE CHAR = 'U';
	DECLARE SOURCE_MANUAL CHAR = 'M';
	DECLARE SOURCE_SYSTEM CHAR = 'S';
	
	-- Get dataset chain
	CALL "sap.tm.trp.routing.db.dataset::p_get_dataset_chain"(
	    :dataset_id,
	    :dataset_chain
	);
	
	-- Revert dataset chain
	dataset_chain_reverted = SELECT id
	FROM (SELECT id, ROW_NUMBER() OVER() AS row_number
	FROM :dataset_chain) ORDER BY row_number DESC;
	
	path_tmp = SELECT 0 AS id, to_binary('') AS hash, '' AS action
	FROM DUMMY WHERE 1 <> 1; 
	
	-- There is no path in local dataset.
	-- Otherwise source from system should be added to the result
	FOR row AS c_dataset(:dataset_chain_reverted) DO
	
	    -- Always add system path
	    
	    path_tmp_current = 
	    SELECT p.id, p.hash, '' AS action
	    FROM "sap.tm.trp.routing.db.dataset::t_path" AS p
	    INNER JOIN :filter AS f
	    ON p.hash = f.hash
	    WHERE p.dataset_id = row.id AND p.source = SOURCE_SYSTEM;
	    
	    path_tmp = SELECT id, hash, '' AS action
	    FROM :path_tmp
	    WHERE hash NOT IN (SELECT DISTINCT hash FROM :path_tmp_current)
	    UNION ALL
	    SELECT * FROM :path_tmp_current;
	    
	    path_delta = SELECT p.id, p.hash, p.action
	    FROM "sap.tm.trp.routing.db.dataset::t_path" AS p
	    INNER JOIN :filter AS f
	    ON p.hash = f.hash
	    WHERE p.dataset_id = row.id AND p.source = SOURCE_MANUAL;
	    
	    -- E means exists
    	-- E | C => E -> Conflicted
    	-- E | U => U
    	-- E | D => 
    	--   | C => C
    	--   | D =>   -> Conflicted
    	--   | U =>   -> Conflicted
	    
	    creation_delta = SELECT id, hash, action
    	FROM :path_delta
    	WHERE action = :ACTION_CREATE
    	AND hash NOT IN (SELECT DISTINCT hash FROM :path_tmp);
    	
    	update_delta = SELECT id, hash, action
    	FROM :path_delta
    	WHERE action = :ACTION_UPDATE
    	AND hash IN (SELECT DISTINCT hash FROM :path_tmp);
    	
    	delete_delta = SELECT id, hash, action
    	FROM :path_delta
    	WHERE action = :ACTION_DELETE;
    	
    	path_tmp = 
    	SELECT * FROM :creation_delta
    	UNION ALL
    	SELECT * FROM :update_delta
    	UNION ALL
    	SELECT * FROM :path_tmp
    	WHERE hash NOT IN (SELECT hash FROM :delete_delta 
    	UNION ALL SELECT hash FROM :update_delta);
	    
	END FOR;
	
	paths = SELECT p.id AS path_id, external_id, from_location, to_location, mtr, carrier,
    t.action, p.hash
    FROM :path_tmp AS t
    INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS p
    ON t.id = p.id;
END