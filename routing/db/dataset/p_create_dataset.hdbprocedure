PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_create_dataset" (
    IN dataset_id BIGINT,
    IN dataset_code NVARCHAR(50),
    IN from_date DATE,
    IN to_date DATE,
    IN locations "sap.tm.trp.routing.db.common::tt_location_id",
    IN connection_list "sap.tm.trp.routing.db.dataset::tt_connection",
    IN connection_carrier "sap.tm.trp.routing.db.dataset::tt_connection_carrier", 
	IN paths "sap.tm.trp.routing.db.dataset::tt_path_external",
	IN path_connection "sap.tm.trp.routing.db.dataset::tt_path_connection",
	OUT return_code TINYINT,
	OUT message "sap.tm.trp.routing.db.common::tt_message"
	) 
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS
BEGIN
   /*************************************
       Write your procedure logic 
   *************************************/
    DECLARE count INTEGER;
	DECLARE path_id_tab TABLE( path_id BIGINT, external_id VARCHAR(50) );
	DECLARE msg_params TABLE(PLACEHOLDER INTEGER, VALUE NVARCHAR(100));
	DECLARE SOURCE_SYSTEM CHAR = 'S';
	
	-- Check whether the dataset code already exists
	DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 301 -- Unique constraint violated
    BEGIN
        select 1 into return_code from dummy;
        msg_param = SELECT 0 AS PLACEHOLDER, dataset_code AS VALUE FROM DUMMY;
	    call "SAP_TM_ROUTING"."sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_DATASET_CODE_ALREADY_EXIST', :msg_param, 'E', :message);
    END;
    
    return_code = 0;
    
    message = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
	log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
    
    SELECT COUNT(*) INTO count FROM "sap.tm.trp.routing.db.dataset::t_dataset"
    WHERE code = :dataset_code;
    
    IF count > 0 THEN
        return_code = 1;
        msg_param = SELECT 0 AS PLACEHOLDER, dataset_code AS VALUE FROM DUMMY;
	    call "SAP_TM_ROUTING"."sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_DATASET_CODE_ALREADY_EXIST', :msg_param, 'E', :message);
        RETURN;
    END IF;
    
    -- Check dataset code
	msg_param = SELECT 0 AS PLACEHOLDER, '' AS VALUE FROM DUMMY WHERE 1 <> 1;
	CALL "sap.tm.trp.routing.db.util::p_validate_code"(
	    :dataset_code,
	    :return_code,
	    :message
	);
	
	IF :return_code <> 0 THEN
        return;
	END IF;
	
	-- From date must not be later than to date
	IF :from_date > :to_date THEN
	    select 1 into return_code from dummy;
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_DATE_RANGE_INVALID', :msg_param, 'E', :message);
        return;
	END IF;
	
	CALL "sap.tm.trp.routing.db.dataset::p_validate_location_list"(
	    :locations, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
    
    -- Aggregate connection by from location, to location and mtr
    -- So the combination is unique in the dataset
    connection_aggregated = SELECT ROW_NUMBER() OVER () AS id, from_location, to_location, mtr,
    distance, duration
    FROM (SELECT from_location, to_location, mtr, AVG(distance) AS distance, 
    AVG(duration) AS duration
    FROM :connection_list
    GROUP BY from_location, to_location, mtr);
    
    connection_carrier_aggregated = SELECT DISTINCT a.id AS connection_id, carrier
    FROM :connection_list AS m
    INNER JOIN :connection_carrier AS c
    ON m.id = c.connection_id
    INNER JOIn :connection_aggregated AS a
    ON a.from_location  = m.from_location
    AND a.to_location = m.to_location
    AND a.mtr = m.mtr;
	
	CALL "sap.tm.trp.routing.db.dataset::p_validate_connection"(
	    :connection_aggregated, :connection_carrier_aggregated, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Use type + name to identify external single-stage path
	-- ID is too technical
	paths_to_validated = SELECT CASE WHEN name = '' OR NAME IS NULL THEN id ELSE CONCAT(type, name) END AS id,
	from_location, to_location, mtr, carrier
	FROM :paths;
	
	path_connection_to_validated = SELECT CASE WHEN p.name = '' OR p.NAME IS NULL THEN c.path_id ELSE SUBSTRING(CONCAT(p.type, p.name), 1, 50) END AS path_id,
	sequence, c.from_location, c.to_location, distance, duration, stay_time, cutoff_offset, availability_offset
	FROM :path_connection c
	LEFT OUTER JOIN :paths p
	ON c.path_id = p.id;
	
	CALL "sap.tm.trp.routing.db.dataset::p_validate_path"(
	    :paths_to_validated, :path_connection_to_validated, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	    RETURN;
	END IF;
    
    -- Global dataset is used as base dataset for all the local dataset
    IF :dataset_id <> 0 THEN
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_dataset"
    	( id, code, source, base_dataset_id, valid_from, valid_to, created_by, 
    	created_on, changed_by, changed_on )
    	VALUES (:dataset_id, :dataset_code,'TM', 0, from_date, to_date, SESSION_CONTEXT('APPLICATIONUSER'), 
    	CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP);
	ELSE
	    -- Set base dataset id to null for global dataset
	    INSERT INTO "sap.tm.trp.routing.db.dataset::t_dataset"
    	( id, code, source, valid_from, valid_to, created_by, created_on, changed_by, changed_on, replicated_by, replicated_on)
    	VALUES (:dataset_id, :dataset_code,'TM', from_date, to_date, SESSION_CONTEXT('APPLICATIONUSER'), 
    	CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP, 
    	SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP);
    END IF;
	
	-- Save Location in t_dataset_location
	INSERT INTO "sap.tm.trp.routing.db.dataset::t_dataset_location" 
	(dataset_id, location_id)
	SELECT :dataset_id as dataset_id, location_id FROM :locations;
	
	SELECT COUNT(*) INTO count FROM :connection_aggregated;
	
	IF count > 0 THEN
	
	-- Save connection
	-- Connection id and bsic path id use the same sequence
	
    	path_tmp = SELECT id, from_location, to_location, mtr, '' AS carrier
    	FROM :connection_aggregated;
    	
    	path_connection_tmp = SELECT id as path_id, 0 AS sequence, from_location, 
    	to_location, distance, duration, 0 as stay_time, 
    	0 AS cutoff_offset, 0 AS availability_offset
    	FROM :connection_aggregated;

    	CALL "sap.tm.trp.routing.db.dataset::p_calculate_path_hash"(
    	    :path_tmp, :path_connection_tmp, :path_hash
    	);
	
    	connection_id_tab = SELECT "sap.tm.trp.routing.db.dataset::s_path".nextval AS connection_id, 
    	id AS external_id 
    	FROM :connection_aggregated;
    	
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_connection" (id, dataset_id, 
    	from_location, to_location, mtr, source, hash, distance, duration)
    	SELECT m.connection_id, :dataset_id as dataset_id, from_location, to_location, 
    	mtr, SOURCE_SYSTEM, p.hash, distance, duration
    	FROM :connection_aggregated as c INNER JOIN :connection_id_tab as m
    	ON c.id = m.external_id
    	INNER JOIN :path_hash AS p
    	ON c.id = p.path_id;
    	
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_connection_carrier" (connection_id, carrier)
    	SELECT m.connection_id as connection_id,c.carrier
    	FROM :connection_carrier_aggregated as c INNER JOIN :connection_id_tab as m
    	ON c.connection_id = m.external_id;
	
	END IF;
	
	SELECT COUNT(*) INTO count FROM :paths;
	
	IF count > 0 THEN
    	-- Save Path and Path Connection in the new dataset
    	-- Calculate hash
    	path_temp = SELECT id, from_location, to_location, mtr, carrier
    	FROM :paths;
    	
    	CALL "sap.tm.trp.routing.db.dataset::p_calculate_path_hash"(
    	    :path_temp, :path_connection, :path_hash
    	);
    	
    	path_id_tab = SELECT "sap.tm.trp.routing.db.dataset::s_path".nextval AS path_id, 
    	id as external_id FROM :paths;
    	
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path"
    	(id, name, external_id, external_type, dataset_id, from_location, to_location, mtr, carrier, source, hash)
    	SELECT A.path_id, B.name, A.external_id, B.type, :dataset_id as dataset_id, from_location, 
    	to_location, mtr, carrier, SOURCE_SYSTEM, H.hash
    	FROM :path_id_tab AS A INNER JOIN :paths AS B ON A.external_id = B.id
    	INNER JOIN :path_hash AS H
    	ON B.id = H.path_id;
    
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path_connection" (path_id, "SEQUENCE", 
    	from_location, to_location, distance, duration, stay_time, cutoff_offset, availability_offset)
    	SELECT A.path_id, sequence, from_location, to_location, distance, duration, 
    	stay_time, cutoff_offset, availability_offset
    	FROM :path_id_tab AS A INNER JOIN :path_connection AS B ON A.external_id = B.path_id;
	
	END IF;
	
	return_code = 0;
END