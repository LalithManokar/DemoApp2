PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_apply_delta" (
	IN base_id TABLE(id BIGINT, dataset_id BIGINT, hash VARBINARY(12)),
	IN delta_id TABLE(id BIGINT, dataset_id BIGINT, action CHAR, hash VARBINARY(12)),
	--OUT return_code TINYINT,
	OUT merged_id TABLE(id BIGINT, dataset_id BIGINT, hash VARBINARY(12)),
	OUT conflict_id TABLE(id BIGINT, dataset_id BIGINT)
	--OUT fatal_conflict_id TABLE(id BIGINT, dataset_id BIGINT)
) 
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   READS SQL DATA AS
BEGIN
	/*******************************************************
	base_id: accumulated path or connection up to lower layer
	delta_id: delta path or connection for current layer(it is required that there is no conflict in delta_id)
	merged_id: merge path or connection with base_id and delta_id
	conflict_id: the conflicts that have been detected during merge
	
	Prequisites: there can be no case the same hash appears more than one time in the same layer.
	*******************************************************/
	-- decl_list
	DECLARE ACTION_UPSERT CHAR = 'U';
	DECLARE ACTION_DELETE CHAR = 'D';
	DECLARE ACTION_CREATE CHAR = 'C';
	-- exception_list
	-- stmt_list

	-- Start to merge
	-- Conflict Rule: For Create Delta, the lower layer must not exist the same hash
	-- Conflict Rule: For Delete Delta, the lower layer should exist the same hash
	-- Conflict Rule: For Upsert Delta, no matter whether the lower layer exist the same hash
	create_delta = 
	SELECT A.*, B.id AS old_id
	FROM :delta_id AS A LEFT OUTER JOIN :base_id AS B ON A.hash = B.hash
	WHERE A.action = :ACTION_CREATE;

	delete_delta = 
	SELECT A.*, B.id AS old_id
	FROM :delta_id AS A LEFT OUTER JOIN :base_id AS B ON A.hash = B.hash
	WHERE A.action = :ACTION_DELETE;

	upsert_delta = 
	SELECT A.*, B.id AS old_id
	FROM :delta_id AS A LEFT OUTER JOIN :base_id AS B ON A.hash = B.hash
	WHERE A.action = :ACTION_UPSERT;

	-- Collect the conflict delta
	-- Since there are possibility that base_id contains paths or connections that are duplicate with regard to hash_id,
	-- But delta part should not be duplicated, so here use distinct to unique the id set
	pure_conflict_id = 
	SELECT distinct id
	FROM :create_delta
	WHERE old_id IS NOT NULL
	UNION ALL
	SELECT distinct id
	FROM :delete_delta
	WHERE old_id IS NULL;

	conflict_id = 
	SELECT A.id, dataset_id
	FROM :pure_conflict_id AS A INNER JOIN :delta_id AS B ON A.id = B.id;

	-- merge create_delta, delete_delta, upsert_delta
	-- Since there are possibility that base_id contains paths or connections that are duplicate with regard to hash_id,
	-- but delta part should not be duplicated, so here use distinct to unique the id set
	merge_id = 
	SELECT id FROM :base_id
	EXCEPT
	SELECT old_id AS id
	FROM :delete_delta
	WHERE old_id IS NOT NULL
	EXCEPT
	SELECT old_id AS id
	FROM :upsert_delta
	WHERE old_id IS NOT NULL
	UNION ALL
	SELECT distinct id
	FROM :create_delta
	WHERE old_id IS NULL
	UNION ALL
	SELECT distinct id
	FROM :upsert_delta;

	merged_id = 
	SELECT A.*
	FROM :base_id AS A INNER JOIN :merge_id AS B ON A.id = B.id
	UNION ALL
	SELECT A.id, dataset_id, hash
	FROM :delta_id AS A INNER JOIN :merge_id AS B ON A.id = B.id;
END