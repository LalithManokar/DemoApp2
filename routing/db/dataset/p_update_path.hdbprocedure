PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_update_path" (
    IN dataset_id BIGINT,
    IN paths "sap.tm.trp.routing.db.dataset::tt_path",
    IN path_connection "sap.tm.trp.routing.db.dataset::tt_path_connection",
    OUT return_code TINYINT,
    OUT id_map "sap.tm.trp.routing.db.dataset::tt_id_map",
    OUT message "sap.tm.trp.routing.db.common::tt_message",
    OUT log "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS 
BEGIN
    /*************************************
       Write your procedure logic 
    *************************************/
    DECLARE dataset_code NVARCHAR(50);
	DECLARE msg_param TABLE(PLACEHOLDER INTEGER, VALUE NVARCHAR(100));
	DECLARE count INTEGER;
	DECLARE CURSOR c_path_hash(path "sap.tm.trp.routing.db.dataset::tt_path_hash")
	FOR SELECT path_id, hash, str FROM :path;
	DECLARE CURSOR c_path_id(path_id "sap.tm.trp.routing.db.common::tt_id")
	FOR SELECT id FROM :path_id;
	DECLARE CURSOR c_id_map FOR SELECT * FROM :id_map;
	
	DECLARE ACTION_CREATE CHAR = 'C';
	DECLARE ACTION_UPDATE CHAR = 'U';
	DECLARE SOURCE_MANUAL CHAR = 'M';
	DECLARE SOURCE_SYSTEM CHAR = 'S';
	
	-- Check whether the dataset exist or not
	DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299
    BEGIN
        return_code = 1;
        msg_params = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(:dataset_id) AS VALUE FROM DUMMY;
	    call "SAP_TM_ROUTING"."sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_DATASET_ID_NOT_EXIST', :msg_params, 'E', :message);
    END;
	
	return_code = 0; 
	
	log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
	
	-- Validate input
	CALL "sap.tm.trp.routing.db.dataset::p_validate_path"(
	    :paths, :path_connection, :return_code, :message
	);
	
	IF :return_code <> 0 THEN
	  RETURN;
	END IF;
	
	SELECT count(*) INTO count FROM :paths;
	
	IF :count = 0 THEN
	    RETURN;
	END IF;
	
	-- Compute path hash
	CALL "sap.tm.trp.routing.db.dataset::p_calculate_path_hash"(
	   :paths, :path_connection, :path_hash
	);
	
	-- Check whether there is any duplicate in the input
	path_duplicated = SELECT 0 AS path_id, hash, str
	FROM (select hash, str, count(*) as count
	from :path_hash
	group by hash, str) AS a
	WHERE count > 1;
	
	FOR row AS c_path_hash(:path_duplicated) DO
	    return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, row.str AS value FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_PATH_UNIQUENESS_VIOLATED', :msg_param, 'E', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	IF return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Get old path 
	path_old = SELECT p2.*
	FROM :paths AS p1
	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" as p2
	ON p1.id = p2.id;
	
	-- Check path id that does not exist
	path_id = SELECT id
	FROM :paths AS p
	WHERE id NOT IN (SELECT id FROM :path_old);
	
	FOR row AS c_path_id(:path_id) DO
        return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(row.id) AS value FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_PATH_ID_NOT_FOUND', :msg_param, 'E', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	IF return_code <> 0 THEN
	    RETURN;
	END IF;
	
	hash = SELECT hash FROM :path_old
	WHERE dataset_id <> :dataset_id OR source = :SOURCE_SYSTEM;
	
	-- Check existence and lock the dataset
	SELECT code INTO dataset_code 
	FROM "sap.tm.trp.routing.db.dataset::t_dataset"
	WHERE id = :dataset_id FOR UPDATE;
	
	-- Get the path visible in current layer by filter
	CALL "sap.tm.trp.routing.db.dataset::p_get_path_by_hash"(
	    :dataset_id,
	    :hash,
	    :path_exist
	);
	
	-- The path identified by the id cannot be updated when
	-- path with the id exists but it is not visible in the layer if it is not 
	-- in the dataset chain or it is shadowed by some paths below or above.
	-- The void path will not be included in the result. So creation in current layer 
	-- will not be checked
	path_id = SELECT a.id
	FROM (SELECT id FROM :path_old AS o 
	WHERE o.dataset_id <> :dataset_id OR o.source = :SOURCE_SYSTEM) AS a
	WHERE id NOT IN (SELECT path_id FROM :path_exist);
	
	FOR row AS c_path_id(:path_id) DO
        return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(row.id) AS value FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_PATH_ID_NOT_FOUND', :msg_param, 'E', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	IF return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Check whether the hash has been changed for connection from layer below
	path_id = SELECT id
	FROM :path_hash AS h
	INNER JOIN :path_old AS o
	ON o.id = h.path_id
	AND o.hash <> h.hash
	WHERE o.dataset_id <> :dataset_id OR o.action = ACTION_UPDATE; 
	
	FOR row AS c_path_id(:path_id) DO
	    return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(row.id) AS VALUE FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_PATH_HASH_CHANGED', :msg_param, 'E', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	IF return_code <> 0 THEN
	    RETURN;
	END IF;
	
	-- Delete path from current layer. Then we can check whether there is duplicate
	path_cur = SELECT p1.*, h.hash, p2.created_by, p2.created_on, p2.action
	FROM :paths AS p1
	INNER JOIN :path_old AS p2
	ON p1.id = p2.id
	INNER JOIN :path_hash AS h
	ON p1.id = h.path_id
	WHERE p2.dataset_id = :dataset_id AND p2.source = :SOURCE_MANUAL;
	
	SELECT COUNT(*) INTO count FROM :path_cur;
	
	IF :count > 0 THEN
        DELETE FROM "sap.tm.trp.routing.db.dataset::t_path" AS o
        WHERE EXISTS (SELECT id FROM :path_cur AS n WHERE o.id = n.id);
        
        DELETE FROM "sap.tm.trp.routing.db.dataset::t_path_connection" AS o
        WHERE EXISTS (SELECT id FROM :path_cur AS n WHERE o.path_id = n.id);
        
        -- Delete the trip
        -- Check if we can make it reuseable
        trip_id = 
    	SELECT id
    	FROM "sap.tm.trp.routing.db.dataset::t_trip" AS t
    	WHERE path_id IN (SELECT id FROM :path_cur);
    
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip_sequence"
    	WHERE trip_id IN (SELECT id FROM :trip_id);
    
    	DELETE FROM "sap.tm.trp.routing.db.dataset::t_trip"
    	WHERE id IN (SELECT id FROM :trip_id);
    
    END IF;
    -- Check whether there is any duplicate in the current layer
	path_duplicated = SELECT 0 AS path_id, h.hash, str
	FROM :path_hash AS h
	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS p
	ON h.hash = p.hash
	WHERE p.dataset_id = :dataset_id AND p.source = :SOURCE_MANUAL;
	
	FOR row AS c_path_hash(:path_duplicated) DO
	    return_code = 1;
	    msg_param = SELECT 0 AS PLACEHOLDER, row.str AS value FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_PATH_UNIQUENESS_VIOLATED', :msg_param, 'E', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	IF return_code <> 0 THEN
	    RETURN;
	END IF;
	
	IF :count > 0 THEN
    	-- Insert connection in current dataset
    	-- Action should be kept
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path"
    	(id, dataset_id, from_location, to_location, mtr, carrier, action, source, hash,
    	 created_by, created_on, changed_by, changed_on)
    	SELECT id, :dataset_id as dataset_id, from_location, to_location, mtr, carrier, 
        action, :SOURCE_MANUAL, hash, created_by, created_on, 
    	SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
    	FROM :path_cur;
    
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path_connection" (path_id, "SEQUENCE", 
    	from_location, to_location, distance, duration, stay_time, cutoff_offset, availability_offset)
    	SELECT p.id, c.sequence, c.from_location, c.to_location, c.distance, c.duration, c.stay_time,
    	0 AS cutoffset, 0 AS availability_offset
    	FROM :path_connection AS c
    	INNER JOIN :path_cur AS p
    	ON c.path_id = p.id;
	
	END IF;
	-- Create UPDATE delta for connection in layer below
    id_map = SELECT id as external_id, "sap.tm.trp.routing.db.dataset::s_path".nextval AS id
	FROM :path_old AS o
	WHERE o.dataset_id <> :dataset_id OR o.source = :SOURCE_SYSTEM;
	
	SELECT COUNT(*) INTO count FROM :id_map;
	IF :count > 0 THEN
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path"
    	(id, dataset_id, from_location, to_location, mtr, carrier, action, source, hash,
    	 created_by, created_on, changed_by, changed_on)
    	SELECT A.id, :dataset_id as dataset_id, b.from_location, b.to_location, b.mtr, b.carrier, 
    	:ACTION_UPDATE, :SOURCE_MANUAL, o.hash, o.created_by, o.created_on, 
    	SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
    	FROM :id_map AS a
    	INNER JOIN :paths AS b
    	ON A.external_id = B.id
    	INNER JOIN :path_old AS o
    	ON B.id = o.id;
     
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path_connection" (path_id, "SEQUENCE", 
    	from_location, to_location, distance, duration, stay_time, cutoff_offset, availability_offset)
    	SELECT id, sequence, from_location, to_location, distance, duration, stay_time,
    	0 AS cutoffset, 0 AS availability_offset
    	FROM :id_map AS A INNER JOIN :path_connection AS B ON A.external_id = B.path_id;
    	
    	-- Also copy departure rule
    	INSERT INTO "sap.tm.trp.routing.db.dataset::t_path_departure_rule"
    	( path_id, rule_number, cycle_type, pattern, departure_time, timezone, created_by, created_on, changed_by, changed_on )
	    SELECT a.id, rule_number, cycle_type, pattern, departure_time, timezone, SESSION_CONTEXT('APPLICATIONUSER'), 
	    CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
	    FROM :id_map a
	    INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_departure_rule" d
	    ON a.external_id = d.path_id;
	
    END IF;
    
    
	--Invalidate dataset
	-- Network model using the dataset will be invalidated
	-- The invalidation will be executed recursively

	UPDATE "sap.tm.trp.routing.db.dataset::t_dataset"
	SET changed_by = SESSION_CONTEXT('APPLICATIONUSER'), changed_on = CURRENT_UTCTIMESTAMP
	WHERE id = :dataset_id; 
	
    -- Check whether the hash has been changed for connection from layer below
	path_id = SELECT id
	FROM :path_cur; 
	
	FOR row AS c_path_id(:path_id) DO
	    msg_param = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(row.id) AS VALUE FROM DUMMY
	    UNION ALL SELECT 1 AS PLACEHOLDER, :dataset_code AS VALUE FROM DUMMY;
	    
	    call "sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_BASIC_PATH_UPDATED_SUCCESSFULLY', :msg_param, 'I', :message_tmp);
        
        message = SELECT * FROM :message 
        UNION ALL SELECT * FROM :message_tmp;
	END FOR;
	
	FOR row AS c_id_map DO
        msg_param = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(row.external_id) AS VALUE FROM DUMMY
        UNION ALL SELECT 1 AS PLACEHOLDER, TO_NVARCHAR(row.id) AS VALUE FROM DUMMY
        UNION ALL SELECT 2 AS PLACEHOLDER, :dataset_code AS VALUE FROM DUMMY;
        call "SAP_TM_ROUTING"."sap.tm.trp.routing.db.common::p_get_text"
        ('MSG_BASIC_PATH_UPDATED_WITH_SUCCESSFULLY', :msg_param, 'I', :message_tmp);
        
        message = SELECT * FROM :message_tmp
        UNION ALL SELECT * FROM :message;
    END FOR;
    
    CALL "sap.tm.trp.routing.db.path::p_invalidate_network_by_dataset" 
    (:dataset_id, 'X', :return_code, :message_tmp, :log_tmp);
    
    IF :return_code <> 0 THEN
        message = SELECT * FROM :message_tmp;
        log = SELECT * FROM :log_tmp;
        RETURN;
    END IF;
        
    message = SELECT * FROM :message 
    UNION ALL SELECT * FROM :message_tmp;
    log = SELECT * FROM :log 
    UNION ALL SELECT * FROM :log_tmp;
	
	return_code = 0;
END;