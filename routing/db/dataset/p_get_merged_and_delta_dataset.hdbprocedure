PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_get_merged_and_delta_dataset" (
	IN dataset_id BIGINT,
	IN base_dataset_id BIGINT,
	IN cost_model_id BIGINT,
	IN resource_type NVARCHAR(20),
	IN mtr_filter TABLE(mtr NVARCHAR(10)),
	OUT base_path_conn TABLE(name VARCHAR(50), mtr NVARCHAR(10), category VARCHAR(10), location NVARCHAR(50), sequence INTEGER, 
	edge_distance DOUBLE, edge_duration INTEGER, edge_cost double, loc_delay INTEGER, availability_offset INTEGER, cutoff_offset INTEGER, hash_code VARBINARY(32)),
	OUT delta_path_conn TABLE(name VARCHAR(50), mtr NVARCHAR(10), category VARCHAR(10), location NVARCHAR(50), sequence INTEGER, 
	edge_distance DOUBLE, edge_duration INTEGER, edge_cost double, loc_delay INTEGER, availability_offset INTEGER, cutoff_offset INTEGER, hash_code VARBINARY(32), opt_type CHAR)
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   READS SQL DATA AS
BEGIN
   /*************************************
       Write your procedure logic 
   *************************************/
   DECLARE manual_source CONSTANT CHAR = 'M';
   DECLARE system_source CONSTANT CHAR = 'S';
   DECLARE basic_path_type CONSTANT VARCHAR(10) = 'P';
   DECLARE basic_conn_type CONSTANT VARCHAR(10) = 'C';

   CALL "sap.tm.trp.routing.db.dataset::p_get_basic_path_filtered_merged_view"(:base_dataset_id, :mtr_filter, accumulate_path_id, accumulate_path_conflict_delta_id);
   
   CALL "sap.tm.trp.routing.db.dataset::p_get_basic_conn_filtered_merged_view"(:base_dataset_id, :mtr_filter, accumulate_conn_id, accumulate_conn_conflict_delta_id);
   
   -- Fetch the delta path id
   delta_path_id = 
   SELECT id
   FROM "sap.tm.trp.routing.db.dataset::t_path"
   WHERE dataset_id = :dataset_id AND source = :manual_source;

   path_id = 
   SELECT id
   FROM :accumulate_path_id
   UNION ALL
   SELECT id
   FROM :delta_path_id;
   
   delta_conn_id = 
   SELECT id
   FROM "sap.tm.trp.routing.db.dataset::t_connection"
   WHERE dataset_id = :dataset_id AND source = :manual_source;
   
   conn_id = 
   SELECT id
   FROM :accumulate_conn_id
   UNION ALL
   SELECT id
   FROM :delta_conn_id;
   
   -- Fetch transportation cost
   CALL "sap.tm.trp.routing.db.dataset::p_get_transport_cost"(:cost_model_id, :resource_type, :path_id, :conn_id, path_cost, conn_cost);
   
   -- calculate basic path and basic connection measure under base_dataset_id
   path_head = 
   SELECT A.id, B.from_location, mtr, carrier, C.cutoff_offset, hash
   FROM :accumulate_path_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS B ON A.id = B.id
   INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C ON A.id = C.path_id AND C.sequence = 1; -- For each path, the sequence always start with 1
   
   path_detail = 
   SELECT A.id, B.sequence, to_location, distance, duration, C.transport_cost, stay_time, 
   B.availability_offset, LEAD(B.cutoff_offset, 1, 0) OVER (PARTITION BY B.path_id ORDER BY B.sequence) AS cutoff_offset
   FROM :accumulate_path_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.id = B.path_id
   LEFT OUTER JOIN :path_cost AS C ON B.path_id = C.id AND B.sequence = C.sequence;
   
   conn_detail = 
   SELECT A.id, from_location, to_location, mtr, distance, duration, C.transport_cost, hash
   FROM :accumulate_conn_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.id = B.id
   LEFT OUTER JOIN :conn_cost AS C ON A.id = C.id;
   
   base_path_conn = 
   SELECT id AS name, mtr, :basic_path_type AS category, from_location AS location, 0 AS sequence, 0.0 AS edge_distance, 0 AS edge_duration, 0.0 AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, cutoff_offset, hash AS hash_code
   FROM :path_head
   UNION ALL
   SELECT A.id AS name, mtr, :basic_path_type AS category, to_location AS location, sequence, distance AS edge_distance, duration AS edge_duration, transport_cost AS edge_cost, stay_time AS loc_delay, 
   B.availability_offset, B.cutoff_offset, hash AS hash_code
   FROM :path_head AS A INNER JOIN :path_detail AS B ON A.id = B.id
   UNION ALL
   SELECT id AS name, mtr, :basic_conn_type AS category, from_location AS location, 0 AS sequence, 0.0 AS edge_distance, 0 AS edge_duration, 0.0 AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, 0 AS cutoff_offset, hash AS hash_code
   FROM :conn_detail
   UNION ALL
   SELECT id AS name, mtr, :basic_conn_type AS category, to_location AS location, 1 AS sequence, distance AS edge_distance, duration AS edge_duration, transport_cost AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, 0 AS cutoff_offset, hash AS hash_code
   FROM :conn_detail;

    -- calculate basic path and basic connection measure in current delta layer
   delta_path_head = 
   SELECT A.id, B.from_location, mtr, carrier, C.cutoff_offset, hash, action
   FROM :delta_path_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS B ON A.id = B.id
   INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C ON A.id = C.path_id AND C.sequence = 1; -- For each path, the sequence always start with 1
   
   delta_path_detail = 
   SELECT A.id, B.sequence, to_location, distance, duration, C.transport_cost, stay_time,
   B.availability_offset, LEAD(B.cutoff_offset, 1, 0) OVER (PARTITION BY B.path_id ORDER BY B.sequence) AS cutoff_offset
   FROM :delta_path_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.id = B.path_id
   LEFT OUTER JOIN :path_cost AS C ON B.path_id = C.id AND B.sequence = C.sequence;
   
   delta_conn_detail = 
   SELECT A.id, from_location, to_location, mtr, distance, duration, C.transport_cost, hash, action
   FROM :delta_conn_id AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.id = B.id
   LEFT OUTER JOIN :conn_cost AS C ON A.id = C.id;
   
   delta_path_conn = 
   SELECT id AS name, mtr, :basic_path_type AS category, from_location AS location, 0 AS sequence, 0.0 AS edge_distance, 0 AS edge_duration, 0.0 AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, cutoff_offset, hash AS hash_code, action AS opt_type
   FROM :delta_path_head
   UNION ALL
   SELECT A.id AS name, mtr, :basic_path_type AS category, to_location AS location, sequence, distance AS edge_distance, duration AS edge_duration, transport_cost AS edge_cost, stay_time AS loc_delay, 
   B.availability_offset, B.cutoff_offset, hash AS hash_code, action AS opt_type
   FROM :delta_path_head AS A INNER JOIN :delta_path_detail AS B ON A.id = B.id
   UNION ALL
   SELECT id AS name, mtr, :basic_conn_type AS category, from_location AS location, 0 AS sequence, 0.0 AS edge_distance, 0 AS edge_duration, 0.0 AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, 0 AS cutoff_offset, hash AS hash_code, action AS opt_type
   FROM :delta_conn_detail
   UNION ALL
   SELECT id AS name, mtr, :basic_conn_type AS category, to_location AS location, 1 AS sequence, distance AS edge_distance, duration AS edge_duration, transport_cost AS edge_cost, 0 AS loc_delay, 
   0 AS availability_offset, 0 AS cutoff_offset, hash AS hash_code, action AS opt_type
   FROM :delta_conn_detail;
END