PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.connector::p_list_trip" (
    in from_time timestamp,
    in to_time timestamp,
    in basic_path_ids TABLE(
        external_id NVARCHAR(50),
        id BIGINT
    ),
    out trip TABLE( 
         ID NVARCHAR(100), 
         EXTERNAL_ID NVARCHAR(100),
         basic_path_id BIGINT,
         RULE_ID SMALLINT,
         MTR NVARCHAR(10),
         FROM_LOCATION NVARCHAR(50),
         TO_LOCATION NVARCHAR(50),
         DEPART_TIME TIMESTAMP,
         ARRIVAL_TIME TIMESTAMP
    ),
    out trip_location table (
         TRIP_ID NVARCHAR(100),
         SEQUENCE INTEGER,
         LOCATION NVARCHAR(50),
         DISTANCE DOUBLE, 
         DEPART_TIME TIMESTAMP,
         ARRIVAL_TIME TIMESTAMP,
         vehicle_id NVARCHAR(50),
         cutoff_offset INTEGER,
         availability_offset INTEGER
    )
   ) 
    language sqlscript
    sql security invoker
    default schema "SAP_TM_ROUTING"
    READS SQL DATA AS
begin
    DECLARE count INTEGER;
    
    schedules = SELECT s.db_key AS schedule_key, p.id AS basic_path_id,
    ifnull(s.carrier, '') as carrier
    FROM "sap.tm.trp.db.semantic.schedule::v_schedule" s 
    INNER JOIN :basic_path_ids as p
    ON s.db_key = p.external_id;
    
    SELECT COUNT(*) INTO count FROM :schedules;
    
    IF :count > 0 THEN
        -- Arrival time is not availabe in departure but just in departure locations
        departure_keys = select distinct l.parent_key as depature_key, schedule_key, 
        basic_path_id, s.carrier
        from "sap.tm.trp.db.semantic.schedule::v_departure_location" as l
        inner join :schedules as s
        on l.root_key = s.schedule_key
        where  l.arrival_utc between :from_time and :to_time
        OR l.departure_utc between :from_time and :to_time;
        
        departures = select distinct d.db_key, k.basic_path_id, ifnull(r1.rule_id, 0) as rule_id,
        k.schedule_key, k.carrier, d.voyage, r2.schedule,
        to_varchar(d.db_key) as trip_id, -- DB key is used as id. Name is readable and fetched when saving route
        to_timestamp(d.departure_utc) as depart_time, 
        to_timestamp(d.arrival_utc) as arrival_time
        from "sap.tm.trp.db.semantic.schedule::v_departure" d
        inner join :departure_keys as k
        on d.db_key = k.depature_key
        left outer join "sap.tm.trp.db.semantic.schedule::v_departure_rule" as r1
        on d.dep_rule_ref = r1.db_key
        inner join "sap.tm.trp.db.semantic.schedule::v_schedule" as r2
        on d.parent_key = r2.db_key;
        --where to_timestamp(d.departure_utc) between :from_time and :to_time; -- Check whether part of trip can be used
        
        trip_location_temp = select distinct dep.trip_id, l.loc_seq, 
        l.departure_utc as depart_time, 
        l.arrival_utc as arrival_time,
        l.vessel AS vehicle_id,
        CASE WHEN l.cutoff_utc IS NULL OR l.cutoff_utc >= l.departure_utc THEN 0
        ELSE SECONDS_BETWEEN(l.cutoff_utc, l.departure_utc) END
        AS cutoff_offset,
        CASE WHEN l.availability_utc IS NULL OR l.availability_utc <= l.arrival_utc THEN 0
        ELSE SECONDS_BETWEEN(l.arrival_utc, l.availability_utc) END
        AS availability_offset
        from :departures as dep
        inner join "sap.tm.trp.db.semantic.schedule::v_departure_location" as l
        on dep.db_key = l.parent_key
        order by trip_id, l.loc_seq; 
        
        -- Number schedule location and trip location
        -- Distance is saved in the first location in schedule for each segment
        -- We need it for the second location
        -- We also need location name with the same sequence
        -- Locations are renumbered to start from 0 as assumed in route
        schedule_location_temp = select distinct dep.trip_id, l.loc_seq, l.location_name as location, l.distance_km as distance
        from :departures as dep
        inner join "sap.tm.trp.db.semantic.schedule::v_schedule_location" as l
        on dep.schedule_key = l.parent_key
        order by l.loc_seq;
        
        schedule_location_numbered = select trip_id, row_number() over(partition by trip_id order by loc_seq asc) as "SEQUENCE",
        location, distance
        from :schedule_location_temp;
        
        trip_location_numbered = select trip_id, row_number() over(partition by trip_id order by loc_seq asc) as "SEQUENCE", 
        loc_seq, depart_time, arrival_time, vehicle_id, cutoff_offset, availability_offset
        from :trip_location_temp order by trip_id, loc_seq; 
        
        -- Location starts from 0
        schedule_trip_location = select l.trip_id, l.sequence - 1 AS sequence, sl1.location,  
        case when sl2.distance is null then 0 else sl2.distance end as distance, 
        l.depart_time, l.arrival_time, vehicle_id, cutoff_offset, availability_offset
        from :trip_location_numbered as l
        inner join :schedule_location_numbered as sl1
        on l.trip_id = sl1.trip_id and l.sequence = sl1.sequence
        left outer join :schedule_location_numbered as sl2
        on l.trip_id = sl2.trip_id and l.sequence = sl2.sequence + 1;
        
        -- From locatiom, to location and MTR are not built since they can be retrieved from basic path
        schedule_trip = select distinct d.trip_id as id, 
        CASE WHEN D.VOYAGE = '' OR D.VOYAGE IS NULL THEN schedule || '_' || RULE_ID || '_' || 
        TO_VARCHAR(depart_time, 'YYYY-MM-DD-HH24:MI:SS') ELSE VOYAGE END 
        as external_id, 
        basic_path_id, rule_id, '' as mtr, '' as from_location, 
        '' as to_location,d.depart_time, l.arrival_time
        from :departures as d inner join(
        select trip_id, max(arrival_time) as arrival_time
        from :schedule_trip_location group by trip_id ) as l 
        on d.trip_id = l.trip_id
        order by d.trip_id;
    
    ELSE
        
        schedule_trip_location = select '' AS trip_id, 0 AS sequence, '' AS location,  
        0 as distance, NULL AS depart_time,  NULL AS arrival_time, 
        NULL AS vehicle_id, 0 AS cutoff_offset, 0 AS availability_offset
        FROM DUMMY WHERE 1 <> 1;
    
        schedule_trip = SELECT  '' as id, '' as external_id, 
        0 as basic_path_id, 0 AS rule_id, '' as mtr, '' as from_location, 
        '' as to_location, null AS depart_time,  null AS arrival_time
        FROM DUMMY WHERE 1 <> 1;
    END IF;
    
    -- Build trip for TOR
    -- To-do: check how to make this configurable
    -- So specific types of TOR will be considered
    tor = SELECT f.db_key AS tor_key, p.id AS basic_path_id,
    ifnull(f.carrier, '') as carrier
    FROM "sap.tm.trp.db.semantic.order::v_freight_order" f 
    INNER JOIN :basic_path_ids as p
    ON f.db_key = p.external_id
    WHERE tor_cat = 'BO';
    
    SELECT COUNT(*) INTO count FROM :tor;
    
    IF :count > 0 THEN
        tor_stages = SELECT trip_id, RANK() OVER (PARTITION BY trip_id ORDER BY sequence) AS sequence, from_location,
        to_location, distance_km as distance, depart_time, arrival_time, vessel_id
        FROM (SELECT TO_NVARCHAR(t.tor_key) AS trip_id, 
        case s3.stop_seq_pos when 'L' then TO_INT(s2.sequence) + 1000 else TO_INT(s2.sequence) end AS sequence,  -- Bug in TM stage table
        s1.location_name AS from_location, s3.location_name AS to_location, s2.distance_km, 
        s1.sel_time AS depart_time, s3.sel_time AS arrival_time, s2.vessel AS vessel_id
        FROM :tor AS t
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s1
        ON t.tor_key = s1.freight_order_key
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stage" AS s2
        ON s1.db_key = s2.from_stop_key
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s3
        ON s2.to_stop_key = s3.db_key
        WHERE s1.stop_cat = 'O' ORDER BY sequence);
        
        tor_trip_location = SELECT s1.trip_id, s1.sequence, s1.to_location AS location, s1.distance, 
        s2.depart_time, s1.arrival_time, s1.vessel_id AS vehicle_id, 0 AS cutoff_offset, 0 AS availability_offset
        FROM :tor_stages AS s1
        LEFT OUTER JOIN :tor_stages AS s2
        ON s1.trip_id = s2.trip_id
        AND s1.sequence + 1 = s2.sequence
        UNION ALL
        SELECT TO_NVARCHAR(t.tor_key) AS trip_id, 0 AS sequence, l.location_name AS location, 0 AS distance, 
        l.sel_time AS depart_time, NULL AS arrival_time,
        NULL AS vehicle_id, 0 AS cutoff_offset, 0 AS availability_offset
        FROM :tor AS t
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l 
        ON t.tor_key = l.freight_order_key
        WHERE l.stop_seq_pos = 'F';
        
        tor_trip = SELECT TO_NVARCHAR(t.tor_key) as id, TO_NVARCHAR(t.tor_key) as external_id, 
        basic_path_id, 0 AS rule_id, '' as mtr, '' as from_location, 
        '' as to_location, l1.sel_time AS depart_time, l2.sel_time AS arrival_time
        FROM :tor AS t
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l1 
        ON t.tor_key = l1.freight_order_key
        INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l2 
        ON t.tor_key = l2.freight_order_key 
        WHERE l1.stop_seq_pos = 'F' AND l2.stop_seq_pos = 'L';
        
    ELSE
        tor_trip_location = select '' AS trip_id, 0 AS sequence, '' AS location,  
        0 as distance, NULL AS depart_time,  NULL AS arrival_time, NULL AS vehicle_id, 
        0 AS cutoff_offset, 0 AS availability_offset
        FROM DUMMY WHERE 1 <> 1;
    
        tor_trip = SELECT  '' as id, '' as external_id, 
        0 as basic_path_id, 0 AS rule_id, '' as mtr, '' as from_location, 
        '' as to_location, null AS depart_time,  null AS arrival_time
        FROM DUMMY WHERE 1 <> 1;
    END IF;
    
    trip = SELECT * FROM :schedule_trip
    UNION ALL
    SELECT * FROM :tor_trip;
    
    trip_location = SELECT * FROM :schedule_trip_location
    UNION ALL
    SELECT * FROM :tor_trip_location;
    
END; 