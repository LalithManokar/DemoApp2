PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.connector::p_build_basic_path" (
    IN from_time TIMESTAMP,
    IN to_time TIMESTAMP,
    OUT return_code SMALLINT,
    OUT paths TABLE (
        id NVARCHAR(50),
        name NVARCHAR(100),
        type NVARCHAR(10),
        mtr NVARCHAR(10),
        carrier NVARCHAR(50),
        from_location NVARCHAR(50),
        to_location NVARCHAR(50)
    ),
    OUT path_connection TABLE (
        path_id NVARCHAR(50),
        sequence INTEGER,
        from_location NVARCHAR(50),
        to_location NVARCHAR(50),
        distance DOUBLE, 
        duration INTEGER,
        stay_time INTEGER,
        cutoff_offset INTEGER,
        availability_offset INTEGER 
    ),
    OUT message "sap.tm.trp.routing.db.common::tt_message"
   )
    LANGUAGE SQLSCRIPT
    SQL SECURITY INVOKER
    DEFAULT SCHEMA "SAP_TM_ROUTING"
    READS SQL DATA AS
BEGIN
    DECLARE count INTEGER;
    DECLARE msg_param TABLE(placeholder INTEGER, value NVARCHAR(100));
    
    return_code = 0;
    
    SELECT count(*) INTO count
    FROM "sap.tm.trp.db.semantic.schedule::v_schedule_filter";
    
    -- To-do: add pagination later
    
    -- Just filter the schedule WHEN there is any entry in the filter cofig table
    IF count = 0 THEN
        schedule_mtr = SELECT DISTINCT TO_NVARCHAR(db_key) AS id, mot, mtr
        FROM "sap.tm.trp.db.semantic.schedule::v_schedule"
        WHERE val_from_date < :to_time
        AND val_to_date > :from_time;
    ELSE
        schedule_mtr = SELECT DISTINCT TO_NVARCHAR(r.db_key) AS id, r.mot, r.mtr
        FROM "sap.tm.trp.db.semantic.schedule::v_schedule" r
        INNER JOIN "sap.tm.trp.db.semantic.schedule::v_schedule_filter" AS f
        ON r.schedule_type = f.schedule_type
        WHERE val_from_date < :to_time
        AND val_to_date > :from_time;
    END IF;
    
    -- Map MTR
    CALL "sap.tm.trp.routing.db.connector::p_map_mtr"(
        :schedule_mtr, return_code, message, schedule_mapped_mtr
    );
    
    IF :return_code <> 0 THEN
        RETURN;
    END IF;
    
    schedules = SELECT m.id AS key, r.schedule AS name, m.mtr, IFNULL(r.carrier, '') AS carrier
    FROM :schedule_mapped_mtr AS m 
    INNER JOIN "sap.tm.trp.db.semantic.schedule::v_schedule" r
    ON m.id = TO_NVARCHAR(r.db_key);
    
    -- Query schedule locations with name
    -- It will be used to map location
    schedule_locations = SELECT 
    s.key AS schedule_key, l.db_key, location_name, distance_km AS distance
    FROM "sap.tm.trp.db.semantic.schedule::v_schedule_location" l
    INNER JOIN :schedules AS s
    ON TO_NVARCHAR(l.parent_key) = s.key;
    
	-- Query depature rule stage
    -- There might be multiple rules for one schedule
    depart_rule_stages = SELECT s.key AS schedule_key, parent_key AS rule_key, stage_seq,
    stage_start_loc_key AS from_loc_key, stage_end_loc_key AS to_loc_key, 
    r.duration, r.stay_time, r.cutoff_offset, r.availability_offset
    FROM "sap.tm.trp.db.semantic.schedule::v_departure_rule_stage" r
    INNER JOIN :schedules AS s
    ON TO_NVARCHAR(r.root_key) = s.key
    UNION ALL 
    SELECT parent_key AS schedule_key, db_key AS rule_key, 0 AS stage_seq, sch_start_loc_key AS from_loc_key, sch_dest_loc_key AS to_loc_key,
    duration, 0 AS stay_time, cutoff_offset, availability_offset
    FROM "sap.tm.trp.db.semantic.schedule::v_departure_rule"
    WHERE parent_key IN (SELECT schedule_key
    FROM :schedule_locations
    GROUP BY schedule_key
    HAVING COUNT(*) = 2);
    
    -- Renumber the stage sequence
    depart_rule_stages_numbered =
    SELECT schedule_key, from_loc_key, to_loc_key, duration, stay_time, cutoff_offset, availability_offset,
    RANK() over (PARTITION BY rule_key ORDER BY stage_seq) AS seq
    FROM :depart_rule_stages;
    
    -- Aggregate the values of multiple rules
    depart_rule_stages_aggregated = 
    SELECT schedule_key, seq, from_loc_key, to_loc_key, avg(duration) AS duration, 
    AVG(stay_time) AS stay_time, AVG(cutoff_offset) AS cutoff_offset, 
    AVG(availability_offset) AS availability_offset
    FROM :depart_rule_stages_numbered
    group by schedule_key, seq, from_loc_key, to_loc_key;
    
    -- Map the UUID to human readable ID
    schedule_path_connection = SELECT l1.schedule_key AS path_id, l1.seq AS "SEQUENCE", 
    l2.location_name  AS from_location, l3.location_name AS to_location,
    l2.distance, duration, stay_time, cutoff_offset, availability_offset
    FROM :depart_rule_stages_aggregated AS l1
    LEFT OUTER JOIN :schedule_locations AS l2
    ON l1.schedule_key = l2.schedule_key AND l1.from_loc_key = l2.db_key
    LEFT OUTER JOIN :schedule_locations AS l3
    ON l1.schedule_key = l3.schedule_key AND l1.to_loc_key = l3.db_key
    ORDER BY path_id, "SEQUENCE";
    
    -- Find the terminal location
    terminal_locations = SELECT path_id, 
    FIRST_VALUE(from_location ORDER BY sequence) AS from_location,
    LAST_VALUE(to_location ORDER BY sequence) AS to_location
    FROM :schedule_path_connection
    GROUP BY path_id;
    
    -- Fill the source location
    schedule_paths = SELECT s.key AS id, s.name, 'S' AS type, mtr, carrier, from_location, to_location
    FROM :schedules AS s INNER JOIN :terminal_locations AS t
    ON s.key = t.path_id;
    
    -- Build path from TOR
    -- To-do: make this configurable by category, mtr
    -- Now just booking is supported
    tor_mtr =SELECT DISTINCT TO_NVARCHAR(t.db_key) AS id, t.mot, mtr
    FROM "sap.tm.trp.db.semantic.order::v_freight_order" AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" s
    ON t.db_key = s.freight_order_key
    AND s.stop_seq_pos = 'F'
    WHERE tor_cat = 'BO'
    AND s.sel_time > :from_time
    AND s.sel_time < :to_time;
    
    -- Map MTR
    CALL "sap.tm.trp.routing.db.connector::p_map_mtr"(
        :tor_mtr, return_code, message, tor_mapped_mtr
    );
    
    IF :return_code <> 0 THEN
        RETURN;
    END IF;
    
    -- Map mtr
    tor = SELECT distinct t.db_key, tor_id, m.mtr, t.carrier
    from "sap.tm.trp.db.semantic.order::v_freight_order" AS t
    INNER JOIN :tor_mapped_mtr AS m
    on t.db_key = m.id
    where t.db_key not in (
        select distinct r.id
        from :tor_mtr r
        inner join "sap.tm.trp.db.semantic.order::v_freight_order_stage" s
        on r.id = s.freight_order_key
        where s.voyage is not null and s.voyage <> '');
    
    tor_paths = SELECT TO_NVARCHAR(t.db_key) AS id, t.tor_id AS name, 'B' AS type, mtr, carrier, 
    l1.location_name AS from_location, l2.location_name AS to_location
    FROM :tor AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l1 
    ON t.db_key = l1.freight_order_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l2 
    ON t.db_key = l2.freight_order_key 
    WHERE l1.stop_seq_pos = 'F' AND l2.stop_seq_pos = 'L';
    
    stages = SELECT path_id, RANK() OVER (PARTITION BY path_id ORDER BY sequence) AS sequence, from_location,
    to_location, distance_km as distance, duration_net AS duration, depart_time, arrival_time
    FROM (SELECT TO_NVARCHAR(t.db_key) AS path_id, 
    CASE s3.stop_seq_pos WHEN 'L' THEN TO_INT(s2.sequence) + 1000 ELSE TO_INT(s2.sequence) END AS sequence,
    s1.location_name AS from_location, s3.location_name AS to_location, s2.distance_km, 
    CASE WHEN s2.duration_net = 0 AND s1.sel_time IS NOT NULL AND s3.sel_time IS NOT NULL
    THEN SECONDS_BETWEEN(s1.sel_time, s3.sel_time)
    ELSE s2.DURATION_NET END AS duration_net, 
    s1.sel_time AS depart_time, 
    s3.sel_time AS arrival_time
    FROM :tor AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s1
    ON t.db_key = s1.freight_order_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stage" AS s2
    ON s1.db_key = s2.from_stop_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s3
    ON s2.to_stop_key = s3.db_key
    WHERE s1.stop_cat = 'O' ORDER BY sequence);
    
    tor_path_connection = select s1.path_id, s1.sequence, s1.from_location, s1.to_location, s1.distance, s1.duration, 
    CASE WHEN s2.depart_time IS NULL 
    THEN 0 ELSE
    SECONDS_BETWEEN(s1.arrival_time, s2.depart_time) END AS stay_time, 
    0 AS cutoff_offset, 0 AS availability_offset
    FROM :stages AS s1
    LEFT OUTER JOIN :stages AS s2
    ON s1.path_id = s2.path_id
    AND s1.sequence + 1 = s2.sequence
    ORDER BY s1.path_id, s1.sequence;
    
    paths = SELECT * FROM :schedule_paths
    UNION ALL
    SELECT * FROM :tor_paths;
    
    path_connection = SELECT * FROM :schedule_path_connection
    UNION ALL
    SELECT * FROM :tor_path_connection;
    
    SELECT 0 into return_code FROM dummy;
    message = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
    
END;