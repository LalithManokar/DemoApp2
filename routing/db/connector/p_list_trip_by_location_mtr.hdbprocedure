PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.connector::p_list_trip_by_location_mtr" (
    in from_time timestamp,
    in to_time timestamp,
    in location_mtr_pair "sap.tm.trp.routing.db.common::tt_location_mtr_pair",
    out trip TABLE( 
         ID NVARCHAR(100), 
         EXTERNAL_ID NVARCHAR(100),
         BASIC_PATH_EXTERNAL_ID NVARCHAR(100),
         CARRIER NVARCHAR(100),
         RULE_ID SMALLINT,
         MTR NVARCHAR(10),
         FROM_LOCATION NVARCHAR(50),
         TO_LOCATION NVARCHAR(50),
         DEPART_TIME TIMESTAMP,
         ARRIVAL_TIME TIMESTAMP
    ),
    out trip_location table (
         TRIP_ID NVARCHAR(100),
         SEQUENCE INTEGER,
         LOCATION NVARCHAR(50),
         DISTANCE DOUBLE, 
         DURATION BIGINT,
         DEPART_TIME TIMESTAMP,
         ARRIVAL_TIME TIMESTAMP,
         VEHICLE_ID NVARCHAR(50),
         CUTOFF_OFFSET INTEGER,
         AVAILABILITY_OFFSET INTEGER
    )
   ) 
    language sqlscript
    sql security invoker
    default schema "SAP_TM_ROUTING"
    READS SQL DATA AS
begin

    -- Rank by specity
    ranked_mtr_map = SELECT mot, mtr, trp_mtr, 
    CASE WHEN mot = '' AND mtr = '' THEN 3
    WHEN mtr = '' THEN 2
    ELSE 1 END AS rule_rank
    FROM "sap.tm.trp.db.semantic.common::v_mtr_map";
    
    -- Map TM mtr to TRP mtr
    mapped_schedule = SELECT s1.db_key, IFNULL(s2.carrier, '') AS carrier, s1.mtr
    FROM (SELECT s.db_key, FIRST_VALUE(trp_mtr ORDER BY rule_rank) AS mtr
    FROM "sap.tm.trp.db.semantic.schedule::v_schedule" AS s
    INNER JOIN :ranked_mtr_map AS m
    ON (
        (s.mot = m.mot AND s.mtr = m.mtr) OR
        (s.mot = m.mot AND m.mtr = '') OR
        (m.mot = '' AND m.mtr = '')
    ) GROUP BY s.db_key) AS s1
    INNER JOIN "sap.tm.trp.db.semantic.schedule::v_schedule" AS s2
    ON s1.db_key = s2.db_key;
       
    departure_keys =  SELECT DISTINCT l1.parent_key AS departure_key, l1.root_key AS schedule_key,l1.carrier, l1.mtr
    FROM (SELECT parent_key, root_key, loc_seq, location_name, s.carrier, s.mtr
	    FROM "sap.tm.trp.db.semantic.schedule::v_departure_location" AS l
	    INNER JOIN :mapped_schedule AS s
	    ON l.root_key = s.db_key
	    INNER JOIN :location_mtr_pair p
	    ON l.location_name = p.from_location
	    AND s.mtr = p.mtr
	    WHERE arrival_utc BETWEEN :from_time AND :to_time 
	    OR departure_utc BETWEEN :from_time AND :to_time ) AS l1
    INNER JOIN (SELECT parent_key, root_key, loc_seq, location_name
	    FROM "sap.tm.trp.db.semantic.schedule::v_departure_location" AS l
	    INNER JOIN :mapped_schedule AS s
	    ON l.root_key = s.db_key
	    INNER JOIN :location_mtr_pair p
	    ON l.location_name = p.to_location
	    AND s.mtr = p.mtr
	    WHERE arrival_utc BETWEEN :from_time AND :to_time 
	    OR departure_utc BETWEEN :from_time AND :to_time) AS l2
    ON l1.parent_key = l2.parent_key
    AND l1.loc_seq < l2.loc_seq;
        
    departures = SELECT DISTINCT d.db_key, IFNULL(r1.rule_id, 0) AS rule_id,
    k.schedule_key, k.carrier, k.mtr, d.voyage, r2.schedule,
    to_varchar(d.db_key) AS trip_id, -- DB key is used AS id. Name is readable AND fetched when saving route
    to_timestamp(d.departure_utc) AS depart_time, 
    to_timestamp(d.arrival_utc) AS arrival_time -- Quite strange that arrival time is not available. We need to fetch from the last location
    FROM "sap.tm.trp.db.semantic.schedule::v_departure" d
    INNER JOIN :departure_keys AS k
    ON d.db_key = k.departure_key
    left outer join "sap.tm.trp.db.semantic.schedule::v_departure_rule" AS r1
    ON d.dep_rule_ref = r1.db_key
    INNER JOIN "sap.tm.trp.db.semantic.schedule::v_schedule" AS r2
    ON d.parent_key = r2.db_key;
    
    trip_location_temp = SELECT DISTINCT d.trip_id, l.loc_seq, 
    l.departure_utc AS depart_time,
    l.arrival_utc AS arrival_time,
    l.vessel AS vehicle_id,
    l.location_name AS location,
    distance_km,
    duration,
    CASE WHEN l.cutoff_utc IS NULL OR l.cutoff_utc >= l.departure_utc THEN 0
    ELSE SECONDS_BETWEEN(l.cutoff_utc, l.departure_utc) END
    AS cutoff_offset,
    CASE WHEN l.availability_utc IS NULL OR l.availability_utc <= l.arrival_utc THEN 0
    ELSE SECONDS_BETWEEN(l.arrival_utc, l.availability_utc) END
    AS availability_offset
    FROM :departures AS d
    INNER JOIN "sap.tm.trp.db.semantic.schedule::v_departure_location" AS l
    ON d.db_key = l.parent_key;
    
    -- Number trip location starting from 0
    -- Distance is saved in the first location but we need it for the second location    
    schedule_trip_location = SELECT trip_id, ROW_NUMBER() OVER(PARTITION BY trip_id ORDER BY loc_seq ASC) - 1 AS "SEQUENCE",
    location, LAG(distance_km, 1, 0) OVER(PARTITION BY trip_id ORDER BY loc_seq ASC) AS distance,
    LAG(duration, 1, 0) OVER(PARTITION BY trip_id ORDER BY loc_seq ASC) AS duration,
    depart_time, arrival_time, vehicle_id, cutoff_offset, availability_offset
    FROM :trip_location_temp ORDER BY trip_id, loc_seq;
    
    schedule_trip = SELECT DISTINCT d.trip_id AS id, 
    CASE WHEN D.VOYAGE = '' OR D.VOYAGE IS NULL THEN schedule || '_' || RULE_ID || '_' || 
    TO_VARCHAR(depart_time, 'YYYY-MM-DD-HH24:MI:SS') ELSE VOYAGE END 
    AS external_id, TO_NVARCHAR(d.schedule_key) AS basic_path_external_id, 
    d.carrier, d.rule_id, d.mtr, l1.from_location,l2.to_location,d.depart_time, l2.arrival_time
    FROM :departures AS d
    INNER JOIN(
    SELECT l3.trip_id, location AS from_location
    FROM :schedule_trip_location AS l3
    INNER JOIN (SELECT trip_id, min(sequence) AS min_seq FROM :schedule_trip_location GROUP BY trip_id) AS l4
    ON l3.trip_id = l4.trip_id
    AND l3.sequence = l4.min_seq
    ) AS l1 
    ON d.trip_id = l1.trip_id
    INNER JOIN(
    SELECT l5.trip_id, location AS to_location, arrival_time
    FROM :schedule_trip_location AS l5
    INNER JOIN (SELECT trip_id, MAX(sequence) AS max_seq FROM :schedule_trip_location GROUP BY trip_id) AS l6
    ON l5.trip_id = l6.trip_id
    AND l5.sequence = l6.max_seq
    ) AS l2
    ON d.trip_id = l2.trip_id
    ORDER BY d.trip_id;  
        
    
    -- Build trip for TOR
    -- To-do: check how to make this configurable
    -- So specific types of TOR will be considered

    -- Map TM mtr to TRP mtr
    mapped_tor = SELECT f1.db_key  AS tor_key, IFNULL(f2.carrier, '') AS carrier, f1.mtr
    FROM (SELECT f.db_key, FIRST_VALUE(trp_mtr ORDER BY rule_rank) AS mtr
    FROM "sap.tm.trp.db.semantic.order::v_freight_order" AS f
    INNER JOIN :ranked_mtr_map AS m
    ON (
        (f.mot = m.mot AND f.mtr = m.mtr) OR
        (f.mot = m.mot AND m.mtr = '') OR
        (m.mot = '' AND m.mtr = '')
    ) WHERE f.tor_cat = 'BO' GROUP BY f.db_key) AS f1
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order" f2
    ON f1.db_key = f2.db_key;
    
    tor_stages = SELECT tor_key, RANK() OVER (PARTITION BY tor_key ORDER BY sequence) AS sequence, from_location,
    to_location, distance_km AS distance, duration, depart_time, arrival_time, vessel_id, mtr, carrier
    FROM (SELECT t.tor_key, 
    case s3.stop_seq_pos when 'L' then TO_INT(s2.sequence) + 1000 else TO_INT(s2.sequence) end AS sequence,  -- Bug in TM stage table
    s1.location_name AS from_location, s3.location_name AS to_location, s2.distance_km, s2.duration_net AS duration,
    s1.sel_time AS depart_time, s3.sel_time AS arrival_time, s2.vessel AS vessel_id,t.mtr,t.carrier
    FROM :mapped_tor AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s1
    ON t.tor_key = s1.freight_order_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stage" AS s2
    ON s1.db_key = s2.from_stop_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS s3
    ON s2.to_stop_key = s3.db_key
    INNER JOIN :location_mtr_pair AS p
    ON t.mtr = p.mtr
    AND s1.location_name = p.from_location
    AND s3.location_name = p.to_location
    WHERE s1.stop_cat = 'O')
    WHERE depart_time BETWEEN :from_time AND :to_time OR arrival_time BETWEEN :from_time AND :to_time;
    
    tor_trip_location = SELECT TO_NVARCHAR(s1.tor_key) AS trip_id, s1.sequence, s1.to_location AS location, s1.distance, s1.duration,
    s2.depart_time, s1.arrival_time, s1.vessel_id AS vehicle_id, 0 AS cutoff_offset, 0 AS availability_offset
    FROM :tor_stages AS s1
    LEFT OUTER JOIN :tor_stages AS s2
    ON s1.tor_key = s2.tor_key
    AND s1.sequence + 1 = s2.sequence
    UNION ALL
    SELECT TO_NVARCHAR(t.tor_key) AS trip_id, 0 AS sequence, l.location_name AS location, 0 AS distance, 0 AS duration,
    l.sel_time AS depart_time, NULL AS arrival_time,
    NULL AS vehicle_id, 0 AS cutoff_offset, 0 AS availability_offset
    FROM :tor_stages AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l 
    ON t.tor_key = l.freight_order_key
    WHERE l.stop_seq_pos = 'F';
    
    tor_trip = SELECT TO_NVARCHAR(t.tor_key) AS id, TO_NVARCHAR(t.tor_key) AS external_id, TO_NVARCHAR(t.tor_key) AS basic_path_external_id, 
    carrier, 0 AS rule_id, mtr, l1.location_name AS from_location, 
    l2.location_name AS to_location, l1.sel_time AS depart_time, l2.sel_time AS arrival_time
    FROM :tor_stages AS t
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l1 
    ON t.tor_key = l1.freight_order_key
    INNER JOIN "sap.tm.trp.db.semantic.order::v_freight_order_stop" AS l2 
    ON t.tor_key = l2.freight_order_key 
    WHERE l1.stop_seq_pos = 'F' AND l2.stop_seq_pos = 'L';       
    
    trip = SELECT * FROM :schedule_trip
    UNION ALL
    SELECT * FROM :tor_trip;
    
    trip_location = SELECT * FROM :schedule_trip_location
    UNION ALL
    SELECT * FROM :tor_trip_location;
    
END; 