PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_calculate_path_measures" (
	IN cost_model_id BIGINT,
	IN resource_type NVARCHAR(20),
	IN paths TABLE(path_id BIGINT, from_location NVARCHAR(50), to_location NVARCHAR(50)),
	IN path_connections TABLE(path_id BIGINT, sequence INTEGER, basic_path_id BIGINT, path_type VARCHAR(10), from_location NVARCHAR(50), to_location NVARCHAR(50), from_bp_sequence INTEGER, to_bp_sequence INTEGER),
	OUT path_measures "sap.tm.trp.routing.db.path::tt_path_measure",
	OUT path_connection_measures "sap.tm.trp.routing.db.path::tt_path_sequence_measure",
	OUT return_code INTEGER,
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   READS SQL DATA AS 
BEGIN
   /*************************************
       Given with paths and path details, compute transport_duration, distance, transport_cost, load_cost, unload_cost, load_duration, unload_duration for path detail,
       and total cost and total duration for paths
   *************************************/ 
	-- decl_list
	DECLARE basic_path_type CONSTANT CHAR = 'P';
	DECLARE basic_conn_type CONSTANT CHAR = 'C';

	-- To-do: get currency from cost model
	DECLARE cost_currency NVARCHAR(10); 
	DECLARE edge_cost_null_cnt INTEGER;
	-- exception_list
	-- stmt_list

	-- fetch transportation cost
	CALL "sap.tm.trp.db.costmodel::sp_get_transportation_based_cost_info"(:cost_model_id, transport_cost_info);
	transport_cost_info = 
	SELECT *
	FROM :transport_cost_info
	WHERE resource_type = :resource_type OR resource_type = '*';

	-- fetch handling cost
	CALL "sap.tm.trp.db.costmodel::sp_get_handling_based_cost_info"(:cost_model_id, handling_cost_info);
	handling_cost_info = 
	SELECT *
	FROM :handling_cost_info
	WHERE resource_type = :resource_type OR resource_type = '*';

	-- fetch handling duration
	-- Decision from PO, for version 1.1 there is no requirements to do handling duration, so here just retrieve no data!!!
	/*
	transload_duration_info = 
	SELECT location, from_mtr, to_mtr, handling_type, time AS duration FROM "sap.tm.trp.routing.db.common::t_handling_time";
	*/

	-- Compute transport duration and distance
	transport_dist_durations = 
	SELECT A.path_id, A.sequence, 
	SUM(
		CASE 
		WHEN C.sequence = A.to_bp_sequence THEN C.duration 
		ELSE C.duration + C.stay_time 
		END
	) AS transport_duration, SUM(C.distance) AS distance
	FROM :path_connections AS A 
	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C ON A.basic_path_id = C.path_id AND C.sequence >= A.from_bp_sequence AND C.sequence <= A.to_bp_sequence
	WHERE A.path_type = :basic_path_type
	GROUP BY A.path_id, A.sequence
	UNION ALL
	SELECT A.path_id, A.sequence, duration AS transport_duration, distance
	FROM :path_connections AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.basic_path_id = B.id
	WHERE A.path_type = :basic_conn_type;

	-- Compute transload duration
	-- first get the mtr info of each path connection
	-- each basic path has only one carrier
	-- but basic connection may have multiple carriers
	basic_path_detail_with_mtr_carrier = 
	SELECT A.*, B.mtr, B.carrier
	FROM :path_connections AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS B ON A.basic_path_id = B.id
	WHERE A.path_type = :basic_path_type;

	basic_conn_detail_with_mtr_distance = 
	SELECT A.*, B.mtr, B.distance
	FROM :path_connections AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.basic_path_id = B.id
	WHERE A.path_type = :basic_conn_type;

	path_connection_with_mtr = 
	SELECT A.path_id, A.sequence, A.basic_path_id, A.path_type, A.from_location, A.to_location, A.from_bp_sequence, A.to_bp_sequence, A.mtr, 
	(SELECT availability_offset FROM "sap.tm.trp.routing.db.dataset::t_path_connection" AS B WHERE B.path_id = A.basic_path_id AND B.sequence = A.to_bp_sequence) AS availability_offset,
	(SELECT cutoff_offset FROM "sap.tm.trp.routing.db.dataset::t_path_connection" AS C WHERE C.path_id = A.basic_path_id AND C.sequence = A.from_bp_sequence) AS cutoff_offset
	FROM :basic_path_detail_with_mtr_carrier AS A
	UNION ALL
	SELECT path_id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, 0 AS availability_offset, 0 AS cutoff_offset
	FROM :basic_conn_detail_with_mtr_distance;

	path_conn_with_from_to_mtr = 
	SELECT path_id, sequence, to_location, mtr AS from_mtr, LEAD(mtr, 1) OVER (PARTITION BY path_id ORDER BY sequence) AS to_mtr,
	path_type AS from_path_type, LEAD(path_type, 1) OVER (PARTITION BY path_id ORDER BY sequence) AS to_path_type,
	availability_offset, LEAD(cutoff_offset, 1) OVER (PARTITION BY path_id ORDER BY sequence) AS cutoff_offset
	FROM :path_connection_with_mtr;

	-- For handling duration, still use handling_type field to determine the handling type
	-- Decision from PO, for version 1.1 there is no requirements to do handling duration, so here just retrieve no data!!!
	/*
	transload_durations = 
	SELECT path_id, sequence, 
		IFNULL(FIRST_VALUE(duration ORDER BY 
		CASE
		WHEN B.location != '*' AND B.from_mtr != '*' AND B.to_mtr != '*' THEN 0
		WHEN B.location != '*' THEN 1
		WHEN B.from_mtr != '*' THEN 2
		WHEN B.to_mtr != '*' THEN 3
		ELSE 4
		END), 0) AS transload_duration
	FROM :path_conn_with_from_to_mtr AS A LEFT OUTER JOIN :transload_duration_info AS B 
	ON B.handling_type = :transload_type 
	AND (B.location = '*' OR A.to_location = B.location) 
	AND (B.from_mtr = '*' OR A.from_mtr = B.from_mtr) 
	AND (B.to_mtr = '*' OR A.to_mtr = B.to_mtr)
	WHERE A.to_mtr IS NOT NULL AND A.from_path_type = :basic_conn_type AND A.to_path_type = :basic_conn_type
	GROUP BY path_id, sequence
	*/
	transload_durations = 
	SELECT path_id, sequence, 0 AS transload_duration
	FROM :path_conn_with_from_to_mtr
	WHERE to_mtr IS NOT NULL AND from_path_type = :basic_conn_type AND to_path_type = :basic_conn_type
	UNION ALL
	SELECT path_id, sequence, (availability_offset + cutoff_offset) AS transload_duration
	FROM :path_conn_with_from_to_mtr
	WHERE to_mtr IS NOT NULL AND (from_path_type = :basic_path_type OR to_path_type = :basic_path_type);

	/*
	load_durations = 
	SELECT path_id, 0 AS sequence, 
		IFNULL(FIRST_VALUE(duration ORDER BY
		CASE
		WHEN B.location != '*' AND B.from_mtr != '*' AND B.to_mtr != '*' THEN 0
		WHEN B.location != '*' THEN 1
		WHEN B.from_mtr != '*' THEN 2
		WHEN B.to_mtr != '*' THEN 3
		ELSE 4
		END), 0) AS transload_duration
	FROM :path_connection_with_mtr AS A LEFT OUTER JOIN :transload_duration_info AS B
	ON B.handling_type = :load_type
	AND (B.location = '*' OR A.from_location = B.location) 
	AND (B.to_mtr = '*' OR A.mtr = B.to_mtr)
	WHERE A.sequence = 1 AND A.path_type = :basic_conn_type
	GROUP BY path_id
	*/
	load_durations = 
	SELECT path_id, 0 AS sequence, 0 AS transload_duration
	FROM :path_connection_with_mtr
	WHERE sequence = 1 AND path_type = :basic_conn_type
	UNION ALL
	SELECT path_id, 0 AS sequence, cutoff_offset AS transload_duration
	FROM :path_connection_with_mtr
	WHERE sequence = 1 AND path_type = :basic_path_type;

	/*
	unload_durations = 
	SELECT path_id, sequence, 
		IFNULL(FIRST_VALUE(duration ORDER BY
		CASE
		WHEN B.location != '*' AND B.from_mtr != '*' AND B.to_mtr != '*' THEN 0
		WHEN B.location != '*' THEN 1
		WHEN B.from_mtr != '*' THEN 2
		WHEN B.to_mtr != '*' THEN 3
		ELSE 4
		END), 0) AS transload_duration
	FROM :path_conn_with_from_to_mtr AS A LEFT OUTER JOIN :transload_duration_info AS B
	ON B.handling_type = :unload_type
	AND (B.location = '*' OR A.to_location = B.location) 
	AND (B.from_mtr = '*' OR A.from_mtr = B.from_mtr)
	WHERE A.to_mtr IS NULL AND A.from_path_type = :basic_conn_type
	GROUP BY path_id, sequence
	*/
	unload_durations = 
	SELECT path_id, sequence, 0 AS transload_duration
	FROM :path_conn_with_from_to_mtr
	WHERE to_mtr IS NULL AND from_path_type = :basic_conn_type
	UNION ALL
	SELECT path_id, sequence, availability_offset AS transload_duration
	FROM :path_conn_with_from_to_mtr
	WHERE to_mtr IS NULL AND from_path_type = :basic_path_type;

	-- Compute transport cost
	basic_path_seq_transport_cost = 
	SELECT A.path_id, A.sequence, C.sequence AS path_conn_seq, 
	FIRST_VALUE(
		CASE 
			WHEN D.from_location_name = '*' OR D.to_location_name = '*' THEN D.cost * C.distance
			ELSE D.cost
		END 
		ORDER BY D.priority, D.wild_star_count, 
		CASE 
			WHEN D.from_location_name != '*' THEN 1
			WHEN D.to_location_name != '*' THEN 2
			WHEN D.transportation_mode_code != '*' THEN 3
			WHEN D.carrier_id != '*' THEN 4
			ELSE 5
		END
	) AS transport_cost
	FROM :basic_path_detail_with_mtr_carrier AS A
	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C 
	ON A.basic_path_id = C.path_id AND A.from_bp_sequence <= C.sequence AND A.to_bp_sequence >= C.sequence
	LEFT OUTER JOIN :transport_cost_info AS D
	ON (D.from_location_name = '*' OR C.from_location = D.from_location_name) AND
	(D.to_location_name = '*' OR C.to_location = D.to_location_name) AND
	(D.transportation_mode_code = '*' OR A.mtr = D.transportation_mode_code) AND
	(D.carrier_id = '*' OR A.carrier = D.carrier_id)
	GROUP BY A.path_id, A.sequence, C.sequence;
	
	-- Check whether is there any basic path transport cost is null
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :basic_path_seq_transport_cost
	WHERE transport_cost IS NULL;
	
	IF :edge_cost_null_cnt > 0 THEN
	    null_edge_cost_path_conn = 
	    SELECT C.path_id AS id, C.sequence, C.from_location, C.to_location, B.mtr, 'P' AS category
	    FROM :basic_path_seq_transport_cost AS A INNER JOIN :basic_path_detail_with_mtr_carrier AS B
	    ON A.path_id = B.path_id AND A.sequence = B.sequence
	    INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" as C
	    ON B.basic_path_id = C.path_id AND A.path_conn_seq = C.sequence;
	    
	    return_code = 1;
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log = SELECT * FROM :message;
	    RETURN;
	END IF;
	
	basic_path_transport_cost = 
	SELECT path_id, sequence, SUM(transport_cost) AS transport_cost
	FROM :basic_path_seq_transport_cost
	GROUP BY path_id, sequence;

	basic_connection_per_carrier_transport_cost = 
	SELECT A.path_id, A.sequence,
	FIRST_VALUE(
		CASE 
			WHEN D.from_location_name = '*' OR D.to_location_name = '*' THEN D.cost * A.distance
			ELSE D.cost
		END 
		ORDER BY D.priority, D.wild_star_count, 
		CASE 
			WHEN D.from_location_name != '*' THEN 1
			WHEN D.to_location_name != '*' THEN 2
			WHEN D.transportation_mode_code != '*' THEN 3
			WHEN D.carrier_id != '*' THEN 4
			ELSE 5
		END
	) AS transport_cost
	FROM :basic_conn_detail_with_mtr_distance AS A 
	LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_connection_carrier" AS C ON A.basic_path_id = C.connection_id
	LEFT OUTER JOIN :transport_cost_info AS D
	ON (D.from_location_name = '*' OR A.from_location = D.from_location_name) AND
	(D.to_location_name = '*' OR A.to_location = D.to_location_name) AND
	(D.transportation_mode_code = '*' OR A.mtr = D.transportation_mode_code) AND
	(D.carrier_id = '*' OR C.carrier = D.carrier_id)
	GROUP BY A.path_id, A.sequence;
	
	-- Check whether is there any basic connection transport cost is null
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :basic_connection_per_carrier_transport_cost
	WHERE transport_cost IS NULL;
	
	IF :edge_cost_null_cnt > 0 THEN
	    null_edge_cost_path_conn = 
	    SELECT B.basic_path_id AS id, 1 AS sequence, B.from_location, B.to_location, B.mtr, 'C' AS category
	    FROM :basic_connection_per_carrier_transport_cost AS A INNER JOIN :basic_conn_detail_with_mtr_distance AS B
	    ON A.path_id = B.path_id AND A.sequence = B.sequence;

	    return_code = 1;
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log = SELECT * FROM :message;
	    RETURN;
	END IF;

	basic_connection_transport_cost = 
	SELECT path_id, sequence, AVG(transport_cost) AS transport_cost
	FROM :basic_connection_per_carrier_transport_cost
	GROUP BY path_id, sequence;

	transport_costs = 
	SELECT * FROM :basic_path_transport_cost
	UNION ALL
	SELECT * FROM :basic_connection_transport_cost;

	-- Compute transload cost
	-- When there are ties, sum them together
	-- When there are missing value, set the default value as 0
	transload_costs = 
	SELECT A.path_id, A.sequence, (load_cost + unload_cost) AS transload_cost
	FROM (
    	SELECT path_id, sequence, SUM(load_cost) AS load_cost
    	FROM (
    		SELECT path_id, sequence, 
    			IFNULL(B.cost, 0.0) AS load_cost, RANK() OVER (PARTITION BY path_id, sequence ORDER BY B.priority, B.wild_star_count) AS priority
    		FROM :path_conn_with_from_to_mtr AS A LEFT OUTER JOIN :handling_cost_info AS B 
    		ON B.from_mot = '' AND B.to_mot != '' 
    		AND (B.location_name = '*' OR A.to_location = B.location_name) 
    		AND (B.to_mot = '*' OR A.to_mtr = B.to_mot)
    		WHERE A.to_mtr IS NOT NULL
    	)
    	WHERE priority = 1
    	GROUP BY path_id, sequence
	) AS A INNER JOIN (
    	SELECT path_id, sequence, SUM(unload_cost) AS unload_cost
    	FROM (
    		SELECT path_id, sequence, 
    			IFNULL(B.cost, 0.0) AS unload_cost, RANK() OVER (PARTITION BY path_id, sequence ORDER BY B.priority, B.wild_star_count) AS priority
    		FROM :path_conn_with_from_to_mtr AS A LEFT OUTER JOIN :handling_cost_info AS B 
    		ON B.from_mot != '' AND B.to_mot = '' 
    		AND (B.location_name = '*' OR A.to_location = B.location_name) 
    		AND (B.from_mot = '*' OR A.from_mtr = B.from_mot)
    		WHERE A.to_mtr IS NOT NULL
    	)
    	WHERE priority = 1
    	GROUP BY path_id, sequence
	) AS B
	ON A.path_id = B.path_id AND A.sequence = B.sequence;

	-- Compute load and unload cost
	load_costs = 
	SELECT path_id, 0 AS sequence, SUM(transload_cost) AS transload_cost
	FROM (
		SELECT path_id, IFNULL(B.cost, 0.0) AS transload_cost, RANK() OVER (PARTITION BY path_id ORDER BY B.priority, B.wild_star_count) AS priority
		FROM :path_connection_with_mtr AS A LEFT OUTER JOIN :handling_cost_info AS B
		ON B.from_mot = '' AND B.to_mot != ''
		AND (B.location_name = '*' OR A.from_location = B.location_name) 
		AND (B.to_mot = '*' OR A.mtr = B.to_mot)
		WHERE A.sequence = 1
	)
	WHERE priority = 1
	GROUP BY path_id;

	unload_costs = 
	SELECT path_id, sequence, SUM(transload_cost) AS transload_cost
	FROM (
		SELECT path_id, sequence, IFNULL(B.cost, 0.0) AS transload_cost, RANK() OVER (PARTITION BY path_id, sequence ORDER BY B.priority, B.wild_star_count) AS priority 
		FROM :path_conn_with_from_to_mtr AS A LEFT OUTER JOIN :handling_cost_info AS B
		ON B.from_mot != '' AND B.to_mot = ''
		AND (B.location_name = '*' OR A.to_location = B.location_name) 
		AND (B.from_mot = '*' OR A.from_mtr = B.from_mot)
		WHERE A.to_mtr IS NULL
	)
	WHERE priority = 1
	GROUP BY path_id, sequence;

   -- Fetch currency info
   CALL "sap.tm.trp.db.costmodel::sp_cost_model_get"(:cost_model_id, currency_info);
   
   -- CURRENCY CODE MUST EXIST!!!
   SELECT currency_code INTO cost_currency
   FROM :currency_info;
   
	-- compute path connection measures
	path_connection_measures = 
	SELECT A.path_id, A.sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, 
	B.distance, B.transport_duration, IFNULL(D.transload_duration, 0) AS transship_duration, C.transport_cost, IFNULL(E.transload_cost, 0) AS transship_cost
	FROM :path_connection_with_mtr AS A
	INNER JOIN :transport_dist_durations AS B ON A.path_id = B.path_id AND A.sequence = B.sequence
	INNER JOIN :transport_costs AS C ON A.path_id = C.path_id AND A.sequence = C.sequence
	LEFT OUTER JOIN :transload_durations AS D ON A.path_id = D.path_id AND A.sequence = D.sequence
	LEFT OUTER JOIN :transload_costs AS E ON A.path_id = E.path_id AND A.sequence = E.sequence;

	-- compute path measures
	path_measures = 
	SELECT A.path_id AS id, A.from_location, A.to_location, total_distance, E.transload_cost AS loading_cost, F.transload_cost AS unloading_cost, 
	(E.transload_cost + F.transload_cost + B.total_transload_cost + B.total_transport_cost) AS total_cost, :cost_currency AS cost_currency,
	C.transload_duration AS loading_duration, D.transload_duration AS unloading_duration,
	(C.transload_duration + D.transload_duration + B.total_transload_duration + B.total_transport_duration) AS total_duration
	FROM :paths AS A 
	INNER JOIN (
		SELECT path_id, SUM(distance) AS total_distance, SUM(transport_duration) AS total_transport_duration, 
		SUM(transport_cost) AS total_transport_cost, SUM(transship_duration) AS total_transload_duration, SUM(transship_cost) AS total_transload_cost
		FROM :path_connection_measures
		GROUP BY path_id
	) AS B ON A.path_id = B.path_id
	INNER JOIN :load_durations AS C ON A.path_id = C.path_id
	INNER JOIN :unload_durations AS D ON A.path_id = D.path_id
	INNER JOIN :load_costs AS E ON A.path_id = E.path_id
	INNER JOIN :unload_costs AS F ON A.path_id = F.path_id;
	
	return_code = 0;
END