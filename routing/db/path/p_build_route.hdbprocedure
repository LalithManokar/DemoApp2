PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_build_route" ( 
    IN network_id BIGINT,
    IN cost_model_id BIGINT,
    IN resource_type NVARCHAR(20),
	IN loc_pair "sap.tm.trp.routing.db.path::tt_location_pair",
	IN composite_path_id "sap.tm.trp.routing.db.common::tt_id",
	IN options "sap.tm.trp.routing.db.common::tt_option",
	OUT route_path "sap.tm.trp.routing.db.path::tt_route_path",
	OUT route_sequence "sap.tm.trp.routing.db.path::tt_route_sequence",
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log_message "sap.tm.trp.routing.db.common::tt_message", 
	OUT return_code INTEGER
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS
BEGIN 
   /*************************************
       Write your procedure logic 
   *************************************/
   DECLARE global_dataset_id CONSTANT BIGINT = 0;
   DECLARE local_dataset_id BIGINT;
   DECLARE from_time, to_time TIMESTAMP;
   DECLARE edge_cost_null_cnt INTEGER;
   DECLARE err_path VARCHAR(50);
   DECLARE start_seq_no CONSTANT INTEGER = 0;
   DECLARE count INTEGER;
   
   DECLARE network_exist INTEGER;
   
   DECLARE total_missed_location INTEGER;
   DECLARE missed_location_arr NVARCHAR(50) ARRAY;
   DECLARE loc_iter INTEGER;
   
   DECLARE storage_cost_cnt INTEGER;
   
   DECLARE origin_time TIMESTAMP; -- Use as origin time, all timestamp should occur after 2000-01-01!!!
   
   SELECT TO_TIMESTAMP('2000-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS') INTO origin_time
   FROM DUMMY;
   
	SELECT COUNT(*) INTO network_exist FROM "sap.tm.trp.routing.db.path::t_network_model" WHERE id = :network_id;
	IF :network_exist = 0 THEN
	    msg_params = SELECT 0 AS PLACEHOLDER, TO_NVARCHAR(:network_id) AS VALUE FROM DUMMY;
	    CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_NETWORK_ID_NOT_EXIST', :msg_params, 'E', message);
	    log_message = SELECT * FROM :message;
	    return_code = 1;
	    RETURN;
	END IF;

-- Check is disabled at the moment since the method will just be called internally.
-- Enable it when necessary. But locations are saved in base dataset.

----validate all locations in location pairs exist, otherwise terminate the program
--SELECT dataset_id INTO local_dataset_id FROM "sap.tm.trp.routing.db.path::t_network_model" WHERE CODE = :network_code;
--from_missed_set = 
--SELECT from_location
--FROM :loc_pair AS A 
--LEFT OUTER JOIN 
--(SELECT location_id FROM "sap.tm.trp.routing.db.dataset::t_dataset_location" WHERE dataset_id = :local_dataset_id) AS B 
--ON A.from_location = B.location_id;
--
--to_missed_set = 
--SELECT to_location
--FROM :loc_pair AS A
--LEFT OUTER JOIN 
--(SELECT location_id FROM "sap.tm.trp.routing.db.dataset::t_dataset_location" WHERE dataset_id = :local_dataset_id) AS B
--ON A.to_location = B.location_id;
--
--total_missed_set = 
--SELECT from_location AS location_id FROM :from_missed_set
--UNION
--SELECT to_location AS location_id FROM :to_missed_set;
--
--SELECT COUNT(location_id) INTO total_missed_location
--FROM :total_missed_set;
--IF :total_missed_location > 0 THEN
--    msg_params = SELECT 0 AS PLACEHOLDER, :total_missed_location AS VALUE FROM DUMMY;
--    CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_LOCATION_NOT_EXIST', :msg_params, 'E', message);
--    log_message = SELECT * FROM :message;
--    -- Output each missed location
--    missed_location_arr = ARRAY_AGG(:total_missed_set.location_id);
--    FOR loc_iter IN 1..CARDINALITY(:missed_location_arr) DO
--        DECLARE missed_location VARCHAR(50) = :missed_location_arr[:loc_iter];
--	    msg_params = SELECT 0 AS PLACEHOLDER, :missed_location AS VALUE FROM DUMMY;
--	    CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_SPECIFIC_LOCATION_MISSING', :msg_params, 'E', message_tmp);
--	    message = 
--	    SELECT * FROM :message
--	    UNION ALL
--	    SELECT * FROM :message_tmp;
--	    
--	    log_message = 
--	    SELECT * FROM :log_message
--	    UNION ALL
--	    SELECT * FROM :message_tmp;
--    END FOR;
--    return_code = 1;
--    RETURN;
--END IF;

   SELECT MIN(DPT_TIME), MAX(ARV_TIME) INTO from_time, to_time FROM :loc_pair;

   location_pair_set = 
   SELECT from_location AS st_location, SECONDS_BETWEEN(:origin_time, dpt_time) AS dpt_time, to_location AS ed_location, SECONDS_BETWEEN(:origin_time, arv_time) AS arv_time
   FROM :loc_pair;
   
   -- Get merged composite path
   /*
   CALL "sap.tm.trp.routing.db.path::p_get_composite_path_merged_view"(
       :network_id,
       '',
       '',
       '',
       merged_path_id_tmp,
       conflict_path_id
   );
   */
   
   -- Retrieve Composite Path(from "sap.tm.trp.routing.db.path::t_path" and "sap.tm.trp.routing.db.path::t_path_sequence") with the given location pair and network id
   path_list = SELECT A.id AS path_id, A.from_location, FIRST_VALUE(from_bp_sequence - 1 ORDER BY B.sequence) AS next_bp_sequence
   FROM :composite_path_id AS M
   INNER JOIN "sap.tm.trp.routing.db.path::t_path" AS A
   ON M.id = A.id
   INNER JOIN "sap.tm.trp.routing.db.path::t_path_sequence" AS B ON A.id = B.path_id
   GROUP BY A.id, A.from_location;
   
   path_conn_list_tmp = SELECT TO_VARCHAR(A.path_id) AS name, path_type, A.to_location AS location, sequence, mtr, TO_VARCHAR(basic_path_id) AS basic_path_name, 
   A.to_bp_sequence AS pre_bp_sequence, LEAD(A.from_bp_sequence - 1, 1, 0) OVER (PARTITION BY A.path_id ORDER BY A.sequence ASC) AS next_bp_sequence 
   FROM "sap.tm.trp.routing.db.path::t_path_sequence" AS A INNER JOIN :composite_path_id AS B ON A.path_id = B.id;
   
   -- path_conn_list represent the basic path section in composite path; basic_conn_list represent the basic connection section in 
   --basic_path_conn_list = SELECT name, location, sequence, mtr, basic_path_name FROM :path_conn_list_tmp WHERE path_type = 'P';
   -- Get All (Unique) Basic Path from Composite Path
   basic_path_id_set = SELECT DISTINCT basic_path_name AS basic_path_id 
   FROM :path_conn_list_tmp
   WHERE path_type = 'P';
   
   path_conn_list = 
   SELECT name, location, sequence, mtr, path_type AS category, basic_path_name, pre_bp_sequence, next_bp_sequence FROM :path_conn_list_tmp
   UNION ALL
   SELECT TO_VARCHAR(path_id), from_location AS location, 0, '', '', 0, 0, next_bp_sequence
   FROM :path_list;

   -- Retrieve external id from "sap.tm.trp.routing.db.dataset::t_path"
   --basic_path_id_pair = SELECT external_id, basic_path_id as id FROM :basic_path_id_set INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" ON basic_path_id = id;
   -- Call "sap.tm.trp.routing.db.adaptor::p_list_trip" to get trip info
   --CALL "sap.tm.trp.routing.db.connector::p_list_trip" (:from_time, :to_time, :basic_path_id_pair, trip, trip_location);
   -- TimeStamp Convert to Integer; Retrieve transport cost from "sap.tm.trp.routing.db.cost::t_transport_cost"
   
   basic_path_ids = SELECT basic_path_id as id FROM :basic_path_id_set;
   CALL "sap.tm.trp.routing.db.dataset::p_list_trip" (:from_time, :to_time, :basic_path_ids, trip, trip_location);
     -- TimeStamp Convert to Integer; Retrieve transport cost from "sap.tm.trp.routing.db.cost::t_transport_cost"

   -- retrieve transport cost info
   CALL "sap.tm.trp.db.costmodel::sp_get_transportation_based_cost_info"(:cost_model_id, transport_cost_info);
   
   -- Calculate transport cost
   basic_path_for_cost = 
   SELECT A.basic_path_id AS id, C.sequence, C.from_location, C.to_location, B.mtr, B.carrier, :resource_type AS resource_type, C.distance, C.duration
   FROM :basic_path_id_set AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS B
   ON A.basic_path_id = B.id
   INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C
   ON A.basic_path_id = C.path_id;
   
   CALL "SAP_TM_ROUTING"."sap.tm.trp.routing.db.cost::p_calculate_transport_cost"(:transport_cost_info, :basic_path_for_cost, basic_path_transport_cost);
   
	-- Verify whether there are edge_cost is null, if there is, it means it fails to look up the unit transport cost in table "sap.tm.trp.routing.db.cost::t_transport_cost"
	null_edge_cost_path_conn = 
	SELECT A.id, A.sequence, B.from_location, B.to_location, B.mtr, 'P' AS category 
	FROM :basic_path_transport_cost AS A INNER JOIN :basic_path_for_cost AS B ON A.id = B.id AND A.sequence = B.sequence
	WHERE cost IS NULL;
	
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :null_edge_cost_path_conn;
	
	IF :edge_cost_null_cnt > 0 THEN
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log_message = SELECT * FROM :message;
	    return_code = 1;
	    RETURN;
	END IF;
	
   -- Here assume the trip returned from "sap.tm.trp.routing.db.connector::p_list_trip" have the same encoding for the sequence as in basic path!!!
   -- The trip sequence should be started from 0!!!
   trip_seq_info = 
   SELECT A.id, A.basic_path_id, B.vehicle_id, B.location, B.sequence, B.distance, C.mtr,
   SECONDS_BETWEEN(:origin_time, B.arrival_time) AS arrival_time, SECONDS_BETWEEN(:origin_time, IFNULL(B.depart_time, B.arrival_time)) AS depart_time,
   B.availability_offset, B.cutoff_offset, NULL AS capacity -- NULL capacity means maximum value that can be represented
   FROM :trip AS A INNER JOIN :trip_location AS B ON A.id = B.trip_id
   INNER JOIN "sap.tm.trp.routing.db.dataset::t_path" AS C ON A.basic_path_id = C.id;
   
   basic_path_trip = 
   SELECT A.id AS name, A.basic_path_id AS basic_path_name, A.vehicle_id AS vehicle_name, A.mtr, 'P' AS category, A.location, A.sequence, B.cost, A.distance, arrival_time AS arv_time, depart_time AS dpt_time,
   A.availability_offset, A.cutoff_offset, A.capacity
   FROM :trip_seq_info AS A INNER JOIN :basic_path_transport_cost AS B ON A.basic_path_id = B.id AND A.sequence = B.sequence
   UNION ALL
   SELECT id AS name, basic_path_id AS basic_path_name, vehicle_id AS vehicle_name, mtr, 'P' AS category, location, sequence, 0 AS cost, 0 AS distance, depart_time AS arv_time, depart_time AS dpt_time,
   availability_offset, cutoff_offset, 0 AS capacity
   FROM :trip_seq_info
   WHERE sequence = :start_seq_no;
   
   -- Compute basic connection related cost
   --basic_conn_list = SELECT name, location, sequence, mtr, basic_path_name FROM :path_conn_list_tmp WHERE path_type = 'C';
   basic_conn_list = SELECT distinct basic_path_name FROM :path_conn_list_tmp WHERE path_type = 'C';

   basic_conn_into_account = 
   SELECT A.basic_path_name, 1 AS sequence, B.from_location, B.to_location, B.mtr, :resource_type AS resource_type, B.distance, B.duration
   FROM :basic_conn_list AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.basic_path_name = B.id;

   basic_conn_info = 
   SELECT A.basic_path_name AS id, sequence, from_location, to_location, mtr, IFNULL(C.carrier, '') AS carrier, resource_type, distance, duration
   FROM :basic_conn_into_account AS A LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_connection_carrier" AS C
   ON A.basic_path_name = C.connection_id;
   
   CALL "SAP_TM_ROUTING"."sap.tm.trp.routing.db.dataset::p_calculate_basic_conn_transport_cost"(:transport_cost_info, :basic_conn_info, basic_conn_transport_cost);
   
	-- Verify whether there are edge_cost is null, if there is, it means it fails to look up the unit transport cost in table "sap.tm.trp.routing.db.cost::t_transport_cost"
	null_edge_cost_path_conn = 
	SELECT A.id, sequence, from_location, to_location, mtr, 'C' AS category 
	FROM :basic_conn_transport_cost AS A INNER JOIN :basic_conn_info AS B ON A.id = B.id
	WHERE cost IS NULL;
	
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :null_edge_cost_path_conn;
	
	IF :edge_cost_null_cnt > 0 THEN
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log_message = SELECT * FROM :message;
	    return_code = 1;
	    RETURN;
	END IF;

   -- For basic connection, use the basic path name as the trip name!!!
   basic_conn_trip = 
   SELECT A.basic_path_name AS name, A.basic_path_name, '' AS vehicle_name, mtr, 'C' AS category, to_location AS location, 1 AS sequence, B.cost, 
   distance, duration AS arv_time, duration AS dpt_time, 0 AS availability_offset, 0 AS cutoff_offset, NULL AS capacity -- here dpt_time has no meaning, simply make sure larger or equal to arv_time and not null
   FROM :basic_conn_into_account AS A INNER JOIN :basic_conn_transport_cost AS B ON A.basic_path_name = B.id
   UNION ALL
   SELECT basic_path_name AS name, basic_path_name, '' AS vehicle_name, mtr, 'C' AS category, from_location AS location, 0 AS sequence, 0 AS cost, 0 AS distance, 
   0 AS arv_time, 0 AS dpt_time, 0 AS availability_offset, 0 AS cutoff_offset, 0 AS capacity  -- here arv_time has no meaning, simply make sure smaller or equal than dpt_time and not null
   FROM :basic_conn_into_account;
   
   trip_tab = 
   SELECT * FROM :basic_path_trip
   UNION ALL
   SELECT * FROM :basic_conn_trip;

	CALL "sap.tm.trp.db.costmodel::sp_get_handling_based_cost_info"(:cost_model_id, handling_cost_set_tmp);
	
	handling_cost_set = 
	SELECT location_name AS location, from_mot AS from_mtr, to_mot AS to_mtr, priority, wild_star_count AS star_count, cost
	FROM :handling_cost_set_tmp
	WHERE resource_type = :resource_type OR resource_type = '*';
	/*
   	handling_cost_set = 
	SELECT location, from_mtr, to_mtr, handling_type AS act_type, cost FROM "sap.tm.trp.routing.db.cost::t_handling_cost" WHERE cost_model_id = :cost_model_id;
    */
	-- Decision from PO, for version 1.1 there is no requirements to do handling duration, so here just retrieve no data!!!
	handling_duration_set = 
	SELECT '' AS location, '' AS from_mtr, '' AS to_mtr, 0 AS priority, 0 AS star_count, 0.0 AS duration
	FROM DUMMY
	WHERE 1 != 1;
    /*
   	handling_duration_set = 
	SELECT location, from_mtr, to_mtr, 1 AS priority, 
	(CASE location WHEN '*' THEN 1 ELSE 0 END) + (CASE from_mtr WHEN '*' THEN 1 ELSE 0 END) + (CASE to_mtr WHEN '*' THEN 1 ELSE 0 END) AS star_count,
	time AS duration FROM "sap.tm.trp.routing.db.common::t_handling_time";
	*/

    -- Later here need to adapt to the storage cost api to get the true storage cost
    -- storage cost api will return qantity based cost and time based cost, not sure how to use!!!
    /*
    storage_cost_set = 
    SELECT location, 1 AS priority, CASE location WHEN '' THEN 1 ELSE 0 END AS star_count, MIN(cost) AS unit_cost 
    FROM "sap.tm.trp.routing.db.cost::t_storage_cost" 
    WHERE cost_model_id = :cost_model_id 
    GROUP BY location;
    */
    
    -- To-do: get storage cost from configuration
    CALL "sap.tm.trp.routing.db.cost::p_get_storage_based_cost_info"(:cost_model_id, storage_cost_info);

    storage_cost_set = 
    SELECT location_name AS location, priority, wild_star_count AS star_count, unit_cost
    FROM :storage_cost_info;
    
    
	--network_conf = SELECT name AS parameter_name, value AS str_value FROM "sap.tm.trp.routing.db.path::t_network_model_conf" WHERE network_model_id = :network_id;
	control_parameters = select name as parameter_name, value as str_value from :options;
	
   -- Call Routing Algorithm to retrieve routing info with location pair, composite path, related trip, return results with route_path, route_sequence
    CALL "_SYS_AFL"."TRP_AREA_ROUTE_GENERATE_PROC" (:location_pair_set, :path_conn_list, :trip_tab, :handling_cost_set, :handling_duration_set, :storage_cost_set, :control_parameters, route_seq_tmp, internal_message, ret_code);

    CALL "sap.tm.trp.routing.db.common::p_convert_texts_util"(internal_message => :internal_message, message => message, log_message => log_message);
    SELECT TOP 1 return_code INTO return_code FROM :ret_code;
    IF return_code != 0 THEN
        return_code = 1;
        RETURN;
    END IF;

    route_sequence = 
    SELECT route_id, sequence -1 AS sequence, location, pre_trip_sequence, next_trip_sequence, 
    CASE WHEN basic_path_name = '' THEN NULL 
    ELSE TO_BIGINT(basic_path_name) END AS basic_path_id, 
    CASE WHEN trip_name = '' THEN NULL ELSE trip_name END AS trip_name,
    mtr, category, ADD_SECONDS(:origin_time, dpt_time) AS dpt_time, ADD_SECONDS(:origin_time, arv_time) AS arv_time, 
    distance, storage_cost, handling_cost, transport_cost, act_type
    FROM :route_seq_tmp;
    
    route_path = 
    SELECT route_id, :network_id AS network_model_id, FIRST_VALUE(composite_name ORDER BY sequence) AS composite_path_id, 
    FIRST_VALUE(location ORDER BY sequence) AS st_location, FIRST_VALUE(ADD_SECONDS(:origin_time, dpt_time) ORDER BY sequence) AS dpt_time,
    LAST_VALUE(location ORDER BY sequence) AS ed_location, LAST_VALUE(ADD_SECONDS(:origin_time, arv_time) ORDER BY sequence) AS arv_time
    FROM :route_seq_tmp
    GROUP BY route_id;
    
END