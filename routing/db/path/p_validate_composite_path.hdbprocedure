PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_validate_composite_path" (
	IN paths TABLE(external_id BIGINT, from_location NVARCHAR(50), to_location NVARCHAR(50)),
	IN path_connections TABLE(external_id BIGINT, sequence INTEGER, basic_path_id BIGINT, path_type VARCHAR(10), from_location NVARCHAR(50), to_location NVARCHAR(50)),
	OUT invalid_paths TABLE(external_id BIGINT),
	OUT return_code INTEGER
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   READS SQL DATA AS
BEGIN
   /*************************************
       RETURN_CODE:
       0. Success
       1. start location and end location of composite path is duplicate
       2. from location and end location of some section in composite path is duplicate
       3. some basic connection in composite paths do not exist
       4. some basic path in composite paths do not exist
       5. start location or end location specified in composite path sequence does not comply with start location or end location specified in composite path header
       6. composite path sequence is not consecutive(from to_location in sequence does not equal the from location in next sequence)
   *************************************/
	-- decl_list
	DECLARE basic_path_type CONSTANT CHAR = 'P';
	DECLARE basic_conn_type CONSTANT CHAR = 'C';
	DECLARE err_cnt INTEGER;
	-- exception_list
	-- stmt_list

	-- check whether start location and end location is duplicate
	invalid_paths = 
	SELECT external_id
	FROM :paths
	WHERE from_location = to_location;

	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 1;
		RETURN;
	END IF;

	-- check whether any from location and end location duplicate
	invalid_paths = 
	SELECT DISTINCT external_id
	FROM :path_connections
	WHERE from_location = to_location;


	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 2;
		RETURN;
	END IF;

	-- check whether basic connection from location and to location exist
	invalid_paths = 
	SELECT DISTINCT external_id
	FROM (
		SELECT A.external_id, B.id AS id
		FROM :path_connections AS A LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_connection" AS B ON A.basic_path_id = B.id AND A.from_location = B.from_location AND A.to_location = B.to_location
		WHERE path_type = :basic_conn_type
	)
	WHERE id IS NULL;

	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 3;
		RETURN;
	END IF;

	-- check whether basic path from location and to location exist
	invalid_paths = 
	SELECT external_id
	FROM (
		SELECT external_id, A.basic_path_id, SUM(CASE WHEN B.sequence <= C.sequence THEN 1 ELSE 0 END) AS non_conflict_num
		FROM :path_connections AS A 
		LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.basic_path_id = B.path_id AND A.from_location = B.from_location
		LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C ON A.basic_path_id = C.path_id AND A.to_location = C.to_location
		WHERE path_type = :basic_path_type
		GROUP BY external_id, A.basic_path_id
	)
	GROUP BY external_id
	HAVING SUM(non_conflict_num) = 0;

	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 4;
		RETURN;
	END IF;

	-- check whether the start location and end location is correct
	invalid_paths = 
	SELECT A.external_id
	FROM :paths AS A LEFT OUTER JOIN (
		SELECT external_id, FIRST_VALUE(from_location ORDER BY sequence) AS start_location, LAST_VALUE(to_location ORDER BY sequence) AS end_location
		FROM :path_connections
		GROUP BY external_id
	) AS B ON A.external_id = B.external_id
	WHERE NOT(A.from_location = B.start_location AND A.to_location = B.end_location);

	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 5;
		RETURN;
	END IF;
	
	-- check whether for composite path connections current to_location equal to the next from_location
	invalid_paths = 
	SELECT external_id
	FROM (
    	SELECT external_id, sequence, to_location AS cur_to_location, LEAD(from_location, 1) OVER (PARTITION BY external_id ORDER BY sequence ASC) AS next_from_location
    	FROM :path_connections
	)
	WHERE next_from_location IS NOT NULL AND cur_to_location != next_from_location
	GROUP BY external_id;

	SELECT COUNT(*) INTO err_cnt FROM :invalid_paths;
	IF :err_cnt != 0 THEN
	    return_code = 6;
		RETURN;
	END IF;
	
    return_code = 0;
END