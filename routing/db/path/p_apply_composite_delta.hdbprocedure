PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_apply_composite_delta" (
	IN base_id TABLE(id BIGINT, network_id BIGINT, hash VARBINARY(32)),
	IN delta_id TABLE(id BIGINT, network_id BIGINT, action CHAR, hash VARBINARY(32)),
	OUT merged_id TABLE(id BIGINT, network_id BIGINT, hash VARBINARY(32)),
	OUT conflict_id TABLE(id BIGINT, network_id BIGINT)
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   READS SQL DATA AS
BEGIN
	/*******************************************************
	base_id: accumulated composite path up to previous layer
	delta_id: delta composite path(either system or manual) for current layer(it is required that there is no conflict in delta_id)
	source: indicate to apply which part of delta, either delta generated by systems or delta input manually by end user
	merged_id: merge composite path with base_id and delta_id
	conflict_id: the conflicts that have been detected during merge
	
	Prequisites: there can be no case the same hash appears more than one time in the same layer and same source.
	*******************************************************/
	-- decl_list
	DECLARE ACTION_DELETE CONSTANT CHAR = 'D';
	DECLARE ACTION_CREATE CONSTANT CHAR = 'C';
	-- exception_list
	-- stmt_list

	-- Start to merge
	-- Conflict Rule: For Create Delta, the lower layer must not exist the same hash
	-- Conflict Rule: For Delete Delta, the lower layer should exist the same hash
	create_delta = 
	SELECT A.*, B.id AS old_id
	FROM :delta_id AS A LEFT OUTER JOIN :base_id AS B ON A.hash = B.hash
	WHERE A.action = :ACTION_CREATE;

	delete_delta = 
	SELECT A.*, B.id AS old_id
	FROM :delta_id AS A LEFT OUTER JOIN :base_id AS B ON A.hash = B.hash
	WHERE A.action = :ACTION_DELETE;

	-- Collect the conflict delta
	conflict_id = 
	SELECT id, network_id
	FROM :create_delta
	WHERE old_id IS NOT NULL
	UNION ALL
	SELECT id, network_id
	FROM :delete_delta
	WHERE old_id IS NULL;

	-- merge create_delta, delete_delta
	-- here it must first distract the deletion id and then add new id, since there may be cases the same composite path will be deleted in one target of delta computation
	-- but also added in the other target of delta computation, so the final result is that this kinds of path should still exist.
	merge_id = 
	SELECT id FROM :base_id
	EXCEPT
	SELECT old_id AS id
	FROM :delete_delta
	WHERE old_id IS NOT NULL
	UNION ALL
	SELECT id
	FROM :create_delta
	WHERE old_id IS NULL;

	merged_id = 
	SELECT A.*
	FROM :base_id AS A INNER JOIN :merge_id AS B ON A.id = B.id
	UNION ALL
	SELECT A.id, network_id, hash
	FROM :delta_id AS A INNER JOIN :merge_id AS B ON A.id = B.id;
END
