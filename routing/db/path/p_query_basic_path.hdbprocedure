PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_query_basic_path"(
	IN network_model_id BIGINT, 
	IN from_location NVARCHAR(50),
	IN to_location NVARCHAR(50),
	IN mtr NVARCHAR(10),
	OUT paths "sap.tm.trp.routing.db.dataset::tt_path_out", 
	OUT path_connection "sap.tm.trp.routing.db.dataset::tt_path_connection"
)
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER
	DEFAULT SCHEMA "SAP_TM_ROUTING"
	READS SQL DATA
AS
BEGIN
	DECLARE dataset_id BIGINT;
	DECLARE count INTEGER;
	DECLARE SOURCE_MANUAL CHAR = 'M';
	DECLARE TYPE_PATH CHAR = 'P';
	DECLARE VIEW_TYPE_FULL CHAR = 'F';

	DECLARE from_list TABLE(path_id BIGINT, sequence BIGINT , location NVARCHAR(50));
	DECLARE to_list TABLE(path_id BIGINT, sequence BIGINT , location NVARCHAR(50));
	DECLARE path_seq_start CONSTANT INTEGER = 0;
	
	-- Ignore data not found exception
    -- Client check whether result is empty or not
	DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299
    BEGIN
    END;
    
	SELECT dataset_id
	INTO dataset_id
	FROM "sap.tm.trp.routing.db.path::t_network_model"
	WHERE id = :network_model_id;
	
	CALL "sap.tm.trp.routing.db.path::p_query_composite_path"(
		network_model_id=>:network_model_id,
		view_type=>:VIEW_TYPE_FULL,
		from_location=>'',
		to_location=>'',
    	mtr=>'',
		paths=>composite_path, 
		path_connection=>composite_path_connection);
    
    -- To-do: filter path according to stops in the middle
    -- First filtered by mtr
    path_id = SELECT DISTINCT basic_path_id AS id
	FROM :composite_path_connection AS c
    WHERE path_type = :TYPE_PATH
    AND (:mtr IS NULL OR :mtr = '' OR c.mtr = :mtr);
    
	paths = SELECT a.id, name, external_id, external_type, from_location, to_location, 
	mtr, carrier, 
	CASE WHEN a.dataset_id = :dataset_id AND a.source = :SOURCE_MANUAL THEN action
	ELSE NULL END AS action, 
	source, '' AS conflict_flag, created_by, created_on, changed_by, changed_on
	FROM "sap.tm.trp.routing.db.dataset::t_path" AS a
	INNER JOIN :path_id AS i
	ON a.id = i.id;
	
	path_connection = SELECT c.path_id AS path_id, sequence, 
	c.from_location, c.to_location, distance, duration, stay_time,
	cutoff_offset, availability_offset
	FROM "sap.tm.trp.routing.db.dataset::t_path_connection" AS c
	INNER JOIN :paths AS p
	ON c.path_id = p.id;

	-- if both from_location and to_location is empty, then return
	IF (:from_location IS NULL OR :from_location = '') AND (:to_location IS NULL OR :to_location = '') THEN
	    RETURN;
	END IF;

	-- If at least from_location or to_location is not empty
    path_seq = 
    SELECT id AS path_id , :path_seq_start AS sequence, from_location AS location
    FROM :paths
    UNION ALL
    SELECT path_id, sequence, to_location AS location
    FROM :path_connection;

	start_end_seq = 
	SELECT path_id, MAX(sequence) AS end_seq
	FROM :path_seq
	GROUP BY path_id;
	
	-- if from_location is not empty
	IF :from_location IS NOT NULL AND :from_location != '' THEN
    	from_list = 
    	SELECT A.path_id, sequence, location
    	FROM :path_seq AS A INNER JOIN :start_end_seq AS B ON A.path_id = B.path_id
    	WHERE location = :from_location AND A.sequence != end_seq;
    ELSE
        from_list = 
        SELECT 0 AS path_id, 0 AS sequence, '' AS location
        FROM DUMMY
        WHERE 1 != 1;
    END IF;
    
	-- if to_location is not empty
	IF :to_location IS NOT NULL AND :to_location != '' THEN
    	to_list = 
    	SELECT A.path_id, sequence, location
    	FROM :path_seq AS A INNER JOIN :start_end_seq AS B ON A.path_id = B.path_id
    	WHERE location = :to_location AND A.sequence != :path_seq_start;
    ELSE
        to_list = 
        SELECT 0 AS path_id, 0 AS sequence, '' AS location
        FROM DUMMY
        WHERE 1 != 1;
    END IF;
    
    IF (:from_location IS NOT NULL AND :from_location != '') AND (:to_location IS NOT NULL AND :to_location != '') THEN
        -- if both from_location and to_location are not empty the from_location sequence must less than to_location sequence
        legal_path_id = 
        SELECT DISTINCT A.path_id
        FROM :from_list AS A INNER JOIN :to_list AS B ON A.path_id = B.path_id AND A.sequence < B.sequence;
    ELSE
        legal_path_id = 
        SELECT DISTINCT path_id 
        FROM (
        SELECT path_id FROM :from_list
        UNION ALL
        SELECT path_id FROM :to_list);
    END IF;
    
    paths = 
    SELECT A.*
    FROM :paths AS A INNER JOIN :legal_path_id AS B ON A.id = B.path_id;

    path_connection = 
    SELECT A.*
    FROM :path_connection AS A INNER JOIN :paths AS B ON A.path_id = B.id;
END;
