PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_build_network" ( 
    IN dataset_id BIGINT,
    IN network_code NVARCHAR(50),
	IN cost_model_id BIGINT,
	IN resource_type NVARCHAR(20),
	IN options "sap.tm.trp.routing.db.common::tt_option",
	IN network_id BIGINT,
	OUT return_code INTEGER,
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log_message "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS 
BEGIN 
   /*************************************
       Write your procedure logic 
   *************************************/ 
   	DECLARE global_dataset_id BIGINT := 0;
	DECLARE msg_params TABLE(PLACEHOLDER INTEGER, VALUE NVARCHAR(100));
	DECLARE network_exist INTEGER;
	DECLARE dataset_exist INTEGER;
	DECLARE cost_model_exist INTEGER;
	DECLARE edge_cost_null_cnt INTEGER; -- count the null edge cost
	DECLARE err_path VARCHAR(50);
	DECLARE system_source CONSTANT CHAR = 'S';

	
	DECLARE target_cfg_name CONSTANT NVARCHAR(50) = 'TARGET';
	DECLARE targets TABLE(VALUE VARCHAR(50));
	DECLARE target_arr VARCHAR(50) ARRAY;
	DECLARE cost_currency NVARCHAR(10);
	DECLARE iter INTEGER;
	
	DECLARE mtr_filter TABLE(MTR NVARCHAR(10));
	DECLARE mtr_filter_cnt INTEGER;
	
	return_code = 1;

	-- Compute (Source, Destination) Location Pair based on the location list in the dataset
	location_set = SELECT location_id FROM "sap.tm.trp.routing.db.dataset::t_dataset_location" WHERE dataset_id = :dataset_id;
	location_pair = SELECT A.location_id AS st_location, B.location_id AS ed_location FROM :location_set AS A CROSS JOIN :location_set AS B
	where A.location_id <> B.location_id;
	
	CALL "sap.tm.trp.db.costmodel::sp_get_transportation_based_cost_info"(:cost_model_id, transport_cost_info);
	-- Fetch currency info
   CALL "sap.tm.trp.db.costmodel::sp_cost_model_get"(:cost_model_id, currency_info);
   
   -- CURRENCY CODE MUST EXIST!!!
   SELECT currency_code INTO cost_currency
   FROM :currency_info;
	
    -- Ensure to retrieve distinct value
    mtr_filter = 
    SELECT DISTINCT value AS mtr
    FROM :options
    WHERE name = 'MTR';
    
    SELECT COUNT(*) INTO mtr_filter_cnt
    FROM :mtr_filter;
    
    IF :mtr_filter_cnt = 0 THEN
        connection_set_into_account = 
    	SELECT id, 1 AS sequence, from_location, to_location, mtr, :resource_type AS resource_type, distance, duration
    	from "sap.tm.trp.routing.db.dataset::t_connection"
    	WHERE dataset_id = :global_dataset_id or (dataset_id = :dataset_id AND source = :system_source);
    ELSE
        connection_set_into_account = 
    	SELECT id, 1 AS sequence, from_location, to_location, A.mtr, :resource_type AS resource_type, distance, duration
    	from "sap.tm.trp.routing.db.dataset::t_connection" AS A INNER JOIN :mtr_filter AS C
    	ON A.mtr = C.mtr
    	WHERE dataset_id = :global_dataset_id or (dataset_id = :dataset_id AND source = :system_source);
    END IF;
    
    connection_set_with_carrier = 
	SELECT id, sequence, from_location, to_location, mtr, IFNULL(carrier, '') AS carrier, resource_type, distance, duration
	from :connection_set_into_account AS A LEFT OUTER JOIN "sap.tm.trp.routing.db.dataset::t_connection_carrier" AS B 
	ON A.id = B.connection_id;

	CALL "sap.tm.trp.routing.db.dataset::p_calculate_basic_conn_transport_cost"(:transport_cost_info, :connection_set_with_carrier, basicconn_transport_cost);

	null_edge_cost_path_conn = 
	SELECT A.id, sequence, from_location, to_location, mtr, 'C' AS category 
	FROM :basicconn_transport_cost AS A INNER JOIN :connection_set_with_carrier AS B ON A.id = B.id
	WHERE cost IS NULL;
	
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :null_edge_cost_path_conn;
	
	IF :edge_cost_null_cnt > 0 THEN
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log_message = SELECT * FROM :message;
	    RETURN;
	END IF;

    connection_cost_set = 
	SELECT A.id AS name, mtr, 'C' AS category, to_location AS location, 1 AS sequence, distance AS edge_distance, duration AS edge_duration, cost AS edge_cost, 0 AS loc_delay, 0 AS availability_offset, 0 AS cutoff_offset
	FROM :connection_set_into_account AS A INNER JOIN :basicconn_transport_cost AS B
	ON A.id = B.id
	UNION ALL
	SELECT id AS name, mtr, 'C' AS category, from_location, 0, 0, 0, 0, 0, 0, 0
	FROM :connection_set_into_account;
	
	-- Retrieve Basic Path, among which the edge cost will be retrieved from transport cost "sap.tm.trp.routing.db.cost::t_transport_cost"
	-- Currently always retrieve the whole global basic path!!!
    IF :mtr_filter_cnt = 0 THEN
	    path_set = SELECT id AS path_id, from_location, mtr, carrier FROM "sap.tm.trp.routing.db.dataset::t_path" WHERE dataset_id = :global_dataset_id;
	ELSE
	    path_set = SELECT id AS path_id, from_location, A.mtr, carrier 
	    FROM "sap.tm.trp.routing.db.dataset::t_path" AS A INNER JOIN :mtr_filter AS B
	    ON A.mtr = B.mtr
	    WHERE dataset_id = :global_dataset_id;
	END IF;
	
	basicpath_set = 
	SELECT A.path_id, sequence, B.from_location, B.to_location, mtr, carrier, distance, duration, stay_time, availability_offset, cutoff_offset
	FROM :path_set AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.path_id = B.path_id;
	
	basicpath_for_cost_calc = 
	SELECT path_id AS id, sequence, from_location, to_location, mtr, carrier, :resource_type AS resource_type, distance, duration
	FROM :basicpath_set;
	
	CALL "sap.tm.trp.routing.db.cost::p_calculate_transport_cost"(:transport_cost_info, :basicpath_for_cost_calc, basicpath_transport_cost);
	
	-- Verify whether there are edge_cost is null, if there is, it means it fails to look up the unit transport cost in table "sap.tm.trp.routing.db.cost::t_transport_cost"
	null_edge_cost_path_conn = 
	SELECT A.id, A.sequence, B.from_location, B.to_location, B.mtr, 'P' AS category 
	FROM :basicpath_transport_cost AS A INNER JOIN :basicpath_for_cost_calc AS B ON A.id = B.id AND A.sequence = B.sequence
	WHERE cost IS NULL;
	
	SELECT COUNT(*) INTO edge_cost_null_cnt
	FROM :null_edge_cost_path_conn;
	
	IF :edge_cost_null_cnt > 0 THEN
	    CALL "sap.tm.trp.routing.db.util::p_convert_transport_cost_missing_message"(:null_edge_cost_path_conn, message);
	    log_message = SELECT * FROM :message;
	    RETURN;
	END IF;
	
	basicpathcost_set = 
	SELECT A.path_id AS name, A.mtr, 'P' AS category, A.to_location AS location, A.sequence, distance AS edge_distance, duration AS edge_duration, cost AS edge_cost, stay_time AS loc_delay,
	availability_offset, LEAD(cutoff_offset, 1, 0) OVER (PARTITION BY A.path_id ORDER BY A.sequence) AS cutoff_offset
	FROM :basicpath_set AS A INNER JOIN :basicpath_transport_cost AS B
	ON A.path_id = B.id AND A.sequence = B.sequence
	UNION ALL
	SELECT A.path_id AS name, mtr, 'P' AS category, A.from_location AS location, 0, 0, 0, 0, 0, 0, B.cutoff_offset
	FROM :path_set AS A INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.path_id = B.path_id AND B.sequence = 1; -- The first segment of basic path always start from 1 !!!

	-- For each basic path, add the from_location as sequence 0
	basicpathcost_set = 
	SELECT * FROM :basicpathcost_set
	UNION ALL
	SELECT * FROM :connection_cost_set;
	
	-- Need to merge basic path with global basic connection and local basic connection!!!(TBD)
	-- Retrieve the transhipment cost from "sap.tm.trp.routing.db.cost::t_handling_cost"
	CALL "sap.tm.trp.db.costmodel::sp_get_handling_based_cost_info"(:cost_model_id, tranship_cost_info_tmp);

	tranship_cost_set = 
	SELECT location_name AS location, from_mot AS from_mtr, to_mot AS to_mtr, priority, wild_star_count AS star_count, cost
	FROM :tranship_cost_info_tmp
	WHERE resource_type = :resource_type OR resource_type = '*';

	-- Retrieve the transhipment duration from "sap.tm.trp.routing.db.common::t_handling_time"
	-- Decision from PO, for version 1.1 there is no requirements to do handling duration, so here just retrieve no data!!!
	tranship_duration_set = 
	SELECT '' AS location, '' AS from_mtr, '' AS to_mtr, 0 AS priority, 0 AS star_count, 0.0 AS duration
	FROM DUMMY
	WHERE 1 != 1;
	
    /*
	tranship_duration_set = 
	SELECT location, from_mtr, to_mtr, 1 AS priority, 
	(CASE location WHEN '*' THEN 1 ELSE 0 END) + (CASE from_mtr WHEN '*' THEN 1 ELSE 0 END) + (CASE to_mtr WHEN '*' THEN 1 ELSE 0 END) AS star_count,
	time AS duration FROM "sap.tm.trp.routing.db.common::t_handling_time";
	
	tranship_duration_set = 
	SELECT location, from_mtr, to_mtr, handling_type AS act_type, time AS duration FROM "sap.tm.trp.routing.db.common::t_handling_time";
    */
	-- Configuration Option will be constructed from parameter options, and need to be stored in "sap.tm.trp.routing.db.path::t_network_model_conf"
	-- No longer used, the network configuration is no longer stored in "sap.tm.trp.routing.db.path::t_network_model_conf"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	-- Currently reserved for convenience o testing!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	--INSERT INTO "sap.tm.trp.routing.db.path::t_network_model_conf" ( network_model_id, sequence, name, value )
	--SELECT :network_id, ROW_NUMBER() OVER (), name, value as str_value FROM :options; 
	--control_parameters = select name as parameter_name, value as str_value from :options;
	
	-- Multiple Target is supported
	-- Now each target is independently computed and store the computed composite path in the table
	-- In t_path_target table it stores path_id, target pair; one path_id may share multiple targets
	targets = SELECT TO_VARCHAR(value) AS value FROM :options WHERE name = :target_cfg_name;
	constraints = SELECT * FROM :options WHERE name != :target_cfg_name;
	target_arr = ARRAY_AGG(:targets.value);
	FOR iter IN 1 .. CARDINALITY(:target_arr) DO
	    control_parameters = 
	    SELECT name AS parameter_name, value AS str_value FROM :constraints
	    UNION ALL
	    SELECT :target_cfg_name AS parameter_name, :target_arr[:iter] AS str_value FROM DUMMY;

    	-- Call composite path computation algorithm
    	CALL "_SYS_AFL"."TRP_AREA_PATH_GENERATE_PROC" (:location_pair, :basicpathcost_set, :tranship_cost_set, :tranship_duration_set, :control_parameters, result_path, result_path_detail, ret_message, path_ret_code);

    	-- Record Log from Composite Path Generation
    	-- Severity = 'L'(only record in log), Otherwise(record them both in log and in message)
    	CALL "sap.tm.trp.routing.db.common::p_convert_texts_util"(internal_message => :ret_message, message => message_tmp, log_message => log_message_tmp);
    	message = 
    	SELECT * FROM :message
    	UNION ALL
    	SELECT * FROM :message_tmp;
    	
    	log_message = 
    	SELECT * FROM :log_message
    	UNION ALL
    	SELECT * FROM :log_message_tmp;
    	-- If there exists error, no longer needs to continue
    	SELECT TOP 1 RETURN_CODE INTO return_code FROM :path_ret_code;
    	IF :return_code != 0 THEN
    	    return_code = 1;
    	    RETURN;
    	END IF;
    	
    	-- Compute hash for each path
    	-- For path detail, only store transload duration and transload cost, don't store load duration, load cost, unload duration, unload cost
    	path_detail = 
    	SELECT *
    	FROM (
        	SELECT pathid, sequence - 1 AS sequence, TO_BIGINT(basic_path_name) AS basic_path_id, category AS path_type, 
        	LAG(location, 1) OVER (PARTITION BY pathid ORDER BY sequence ASC) AS from_location,
        	location AS to_location,  LAG(next_bp_sequence + 1, 1) OVER (PARTITION BY pathid ORDER BY sequence ASC) AS from_bp_sequence, pre_bp_sequence AS to_bp_sequence, mtr, distance, transport_duration, 
        	CASE act_type
        	WHEN 'LOD' THEN 0
        	WHEN 'ULD' THEN 0
        	ELSE handling_duration
        	END AS transship_duration, 
        	transport_cost, 
        	CASE act_type
        	WHEN 'LOD' THEN 0
        	WHEN 'ULD' THEN 0
        	ELSE handling_cost
        	END AS transship_cost
        	FROM :result_path_detail
    	)
    	WHERE from_location IS NOT NULL;

    	path_conn_for_hash = 
    	SELECT pathid AS path_id, sequence, basic_path_id, from_location, to_location, from_bp_sequence, to_bp_sequence
    	FROM :path_detail;
    	
        CALL "sap.tm.trp.routing.db.path::p_calculate_composite_path_hash" (:path_conn_for_hash, path_hash);
        
        -- Check whether the same hash has already exist in the same network model system generated non-delta path
        -- If already exist, just update to append the target, Otherwise insert the path
        path_exist_flag = 
        SELECT A.path_id AS pathid, B.id AS id_flag
        FROM :path_hash AS A LEFT OUTER JOIN "sap.tm.trp.routing.db.path::t_path" AS B ON A.hash = B.hash
        AND B.network_model_id = :network_id AND B.source = 'S' AND B.action IS NULL;
    	
    	-- Map composite path id to sequence id for those path not exist previously in current network model
    	map_path_id = 
    	SELECT "sap.tm.trp.routing.db.path::s_composite_path".NEXTVAL AS PATH_ID, PATHID 
    	FROM :path_exist_flag
    	WHERE id_flag IS NULL;
    	-- Store the composite path results into "sap.tm.trp.routing.db.path::t_path" and "sap.tm.trp.routing.db.path::t_path_sequence"
    	INSERT INTO "sap.tm.trp.routing.db.path::t_path" (id, network_model_id, from_location, to_location, total_distance, loading_cost, unloading_cost, total_cost, 
    	cost_currency, loading_duration, unloading_duration, total_duration, action, source, hash, created_by, created_on, changed_by, changed_on)
    	SELECT B.path_id, :network_id, start_loc, destination_loc, total_distance, 
    	(SELECT handling_cost FROM :result_path_detail WHERE pathid = A.pathid AND act_type = 'LOD') AS loading_cost,
    	(SELECT handling_cost FROM :result_path_detail WHERE pathid = A.pathid AND act_type = 'ULD') AS unloading_cost,
    	total_cost, :cost_currency,
    	(SELECT handling_duration FROM :result_path_detail WHERE pathid = A.pathid AND act_type = 'LOD') AS loading_duration,
    	(SELECT handling_duration FROM :result_path_detail WHERE pathid = A.pathid AND act_type = 'ULD') AS unloading_duration,
    	total_duration, NULL, 'S', C.hash,
    	SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
    	FROM :result_path AS A INNER JOIN :map_path_id AS B ON A.pathid = B.pathid
    	INNER JOIN :path_hash AS C ON A.pathid = C.path_id;
    	
    	INSERT INTO "sap.tm.trp.routing.db.path::t_path_sequence" (path_id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost)
    	SELECT path_id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost
    	FROM :path_detail AS A INNER JOIN :map_path_id AS B ON A.pathid = B.pathid;
    	
    	-- Insert the targets of those composite path which haven' exist before
    	INSERT INTO "sap.tm.trp.routing.db.path::t_path_target"(path_id, target)
    	SELECT path_id, :target_arr[:iter]
    	FROM :map_path_id;

    	-- Update the targets of those composite path which have already exist
    	INSERT INTO "sap.tm.trp.routing.db.path::t_path_target"(path_id, target)
    	SELECT id_flag, :target_arr[:iter]
    	FROM :path_exist_flag
    	WHERE id_flag IS NOT NULL;
	END FOR;
	
	return_code = 0;
END