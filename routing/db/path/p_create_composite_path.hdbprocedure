PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_create_composite_path" (
	IN network_id BIGINT,
	IN paths "sap.tm.trp.routing.db.path::tt_composite_path_in",
	IN path_connections "sap.tm.trp.routing.db.path::tt_composite_connection_in",
	OUT return_code INTEGER,
	OUT id_map TABLE(external_id BIGINT, id BIGINT),
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA SAP_TM_ROUTING
   AS
BEGIN
   /*************************************
       RETURN_CODE:
       0. Success
       1. Network ID not exist
       2. Specified Composite path is not valid due to various issue
       3. Exist duplicate composite paths to be created
       4. Composite path to be created is conflict with existing manual composite path in the same layer
       5. Composite path to be created is conflict with existing non-deletion marked composite path in the lower layer
       6. Start Location or End Location of specified composite path does not exist
       7. Transport Cost not found
   *************************************/
	-- decl_list
	DECLARE manual_source CONSTANT CHAR = 'M';
	DECLARE system_source CONSTANT CHAR = 'S';
	DECLARE action_delete CONSTANT CHAR = 'D';
	DECLARE action_create CONSTANT CHAR = 'C';
	DECLARE basic_path_type CONSTANT CHAR = 'P';
	DECLARE basic_conn_type CONSTANT CHAR = 'C';

	DECLARE cost_model_id BIGINT;
	DECLARE currency NVARCHAR(10);
	DECLARE resource_type NVARCHAR(20);
	DECLARE base_network_id, base_dataset_id BIGINT;

	DECLARE path_usage CONSTANT VARCHAR(10) = 'PATH';
	
	DECLARE err_path VARCHAR(50);
	DECLARE transport_err_code INTEGER;
	DECLARE transport_err_message "sap.tm.trp.routing.db.common::tt_message";
	DECLARE transport_err_log "sap.tm.trp.routing.db.common::tt_message";
	
	DECLARE msg_params "sap.tm.trp.routing.db.common::tt_message_placeholder";
	DECLARE msg_params_batch "sap.tm.trp.routing.db.common::tt_message_placeholder_batch";
	-- exception_list
	-- stmt_list

	-- check whether the input network id is illegal
	SELECT CASE COUNT(*) WHEN 0 THEN 1 ELSE 0 END INTO return_code
	FROM "sap.tm.trp.routing.db.path::t_network_model"
	WHERE id = :network_id;

	IF :return_code != 0 THEN
		-- log message
	    msg_params = SELECT 0 AS PLACEHOLDER, :network_id AS VALUE FROM DUMMY;
	    CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_NETWORK_ID_NOT_EXIST', :msg_params, 'E', message);
	    log = SELECT * FROM :message;
		RETURN;
	END IF;
	
	-- validate whether all start location and end location exist in current dataset
	-- Assume all local locations maintained in base network's dataset
	CALL "sap.tm.trp.routing.db.path::p_get_network_chain"(:network_id, network_chain);
	
	SELECT LAST_VALUE(id ORDER BY level) INTO base_network_id 
	FROM :network_chain;
	
	SELECT dataset_id INTO base_dataset_id
	FROM "sap.tm.trp.routing.db.path::t_network_model"
	WHERE id = :base_network_id;
	
	invalid_paths = 
	SELECT external_id
	FROM :paths
	WHERE NOT EXISTS(
	    SELECT location_id 
	    FROM "sap.tm.trp.routing.db.dataset::t_dataset_location" 
	    WHERE dataset_id = :base_dataset_id AND (location_id = from_location OR location_id = to_location)
	);
	
	SELECT CASE COUNT(*) WHEN 0 THEN 0 ELSE 6 END INTO return_code
	FROM :invalid_paths;
	
	IF :return_code != 0 THEN
	    msg_params_batch = 
	    SELECT A.external_id AS group_id, 0 AS placeholder, from_location AS VALUE
	    FROM :invalid_paths AS A INNER JOIN :paths AS B
	    ON A.external_id = B.external_id
	    UNION ALL
	    SELECT A.external_id AS group_id, 1 AS placeholder, to_location AS VALUE
	    FROM :invalid_paths AS A INNER JOIN :paths AS B
	    ON A.external_id = B.external_id;
	    
        CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_LOCATION_NOT_EXIST_IN_LOCAL_DATASET', :msg_params_batch, 'E', :message);
	    log = SELECT * FROM :message;	    
	    RETURN;
	END IF;

	-- validate whether the composite path is suitable
	CALL "sap.tm.trp.routing.db.path::p_validate_composite_path" (:paths, :path_connections, invalid_paths, return_code);

	IF :return_code != 0 THEN
		-- log message
	    msg_params_batch = 
	    SELECT A.external_id AS group_id, 0 AS placeholder, from_location AS VALUE
	    FROM :invalid_paths AS A INNER JOIN :paths AS B
	    ON A.external_id = B.external_id
	    UNION ALL
	    SELECT A.external_id AS group_id, 1 AS placeholder, to_location AS VALUE
	    FROM :invalid_paths AS A INNER JOIN :paths AS B
	    ON A.external_id = B.external_id;

	    IF return_code = 1 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_DUPLICATE_START_END_LOCATION', :msg_params_batch, 'E', :message);
	    ELSEIF return_code = 2 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_DUPLICATE_FROM_TO_LOCATION', :msg_params_batch, 'E', :message);
	    ELSEIF return_code = 3 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_SUB_CONNECTION_NOT_EXIST', :msg_params_batch, 'E', :message);
	    ELSEIF return_code = 4 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_SUB_PATH_NOT_EXIST', :msg_params_batch, 'E', :message);
	    ELSEIF return_code = 5 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_WRONG_START_END_LOCATION', :msg_params_batch, 'E', :message);
	    ELSEIF return_code = 6 THEN
            CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_TO_NOT_EQUAL_NEXT_FROM_LOCATION', :msg_params_batch, 'E', :message);
	    END IF;
	    log = SELECT * FROM :message;
	    
	    return_code = 2;
		RETURN;
	END IF;

	-- compute the hash per composite path
	-- Since there may be duplication node in basic path, currently assume the input from_location and to_location assume always to match the lowest sequence in basic path
	-- First determine the precise node sequence for the from location and to location in basic path
	path_conn_for_hash = 
	SELECT A.external_id AS path_id, A.sequence, B.basic_path_id, B.path_type, B.from_location, B.to_location, from_bp_sequence, to_bp_sequence 
	FROM (
    	SELECT external_id, A.sequence, MIN(B.sequence) AS from_bp_sequence, FIRST_VALUE(C.sequence ORDER BY B.sequence, C.sequence) AS to_bp_sequence
    	FROM :path_connections AS A
    	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS B ON A.basic_path_id = B.path_id AND A.from_location = B.from_location
    	INNER JOIN "sap.tm.trp.routing.db.dataset::t_path_connection" AS C ON A.basic_path_id = C.path_id AND A.to_location = C.to_location
    	WHERE A.path_type = :basic_path_type
    	GROUP BY external_id, A.sequence
	) AS A INNER JOIN :path_connections AS B ON A.external_id = B.external_id AND A.sequence = B.sequence
	UNION ALL
	SELECT external_id AS path_id, sequence, basic_path_id, path_type, from_location, to_location, 1 AS from_bp_sequence, 1 AS to_bp_sequence
	FROM :path_connections
	WHERE path_type = :basic_conn_type;
	
	path_conn_for_hash1 = SELECT path_id, sequence, basic_path_id, from_location, to_location, from_bp_sequence, to_bp_sequence
	                      FROM :path_conn_for_hash;

	CALL "sap.tm.trp.routing.db.path::p_calculate_composite_path_hash" (:path_conn_for_hash1, path_hash);

	-- check conflict composite path in different layer

	-- check whether there are duplication in input itself
	SELECT CASE COUNT(hash) WHEN 0 THEN 0 ELSE 3 END INTO return_code
	FROM (
	SELECT hash
	FROM :path_hash
	GROUP BY hash
	HAVING COUNT(path_id) > 1);

	IF :return_code != 0 THEN
		-- log message
	    msg_params = SELECT 0 AS PLACEHOLDER, '' AS VALUE FROM DUMMY WHERE 1 != 1;
	    CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_DUPLICATE_INPUT_COMPOSITE_PATH', :msg_params, 'E', message);
	    log = SELECT * FROM :message;
		RETURN;
	END IF;

	-- check conflict composite path from layer below
	CALL "sap.tm.trp.routing.db.path::p_get_network_chain"(:network_id, network_chain);

	path_hash_and_flag = 
	SELECT A.hash, A.path_id, FIRST_VALUE(
		CASE
		WHEN level = 1 AND source_flag = 0 THEN 'E'  -- conflict in the same layer and manual entry
		WHEN level IS NOT NULL AND (action IS NULL OR action = :action_create) THEN 'W'  -- conflict with lower layer or same layer system entry and action is not delete
		ELSE 'S'  -- successful, no conflict
		END
		ORDER BY source_flag, level) AS conflict_flag
	FROM :path_hash AS A LEFT OUTER JOIN (
		SELECT CASE source 
			WHEN :manual_source THEN 0 
			WHEN :system_source THEN 1 
			ELSE 1 
			END AS source_flag, level, hash, action
		FROM :network_chain AS A INNER JOIN "sap.tm.trp.routing.db.path::t_path" AS B
		ON A.id = B.network_model_id
	) AS B ON A.hash = B.hash
	GROUP BY A.hash, A.path_id;

	SELECT CASE COUNT(*) WHEN 0 THEN 0 ELSE 4 END INTO return_code
	FROM :path_hash_and_flag
	WHERE conflict_flag = 'E';

	IF :return_code != 0 THEN
		-- log message
	    msg_params_batch = 
	    SELECT A.path_id AS group_id, 0 AS placeholder, from_location AS VALUE
	    FROM :path_hash_and_flag AS A INNER JOIN :paths AS B
	    ON A.path_id = B.external_id
	    WHERE conflict_flag = 'E'
	    UNION ALL
	    SELECT A.path_id AS group_id, 1 AS placeholder, to_location AS VALUE
	    FROM :path_hash_and_flag AS A INNER JOIN :paths AS B
	    ON A.path_id = B.external_id
	    WHERE conflict_flag = 'E';

	    CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_CONFLICT_WITHIN_SAME_LAYER', :msg_params_batch, 'E', message);
	    log = SELECT * FROM :message;
		RETURN;
	END IF;

	SELECT CASE COUNT(*) WHEN 0 THEN 0 ELSE 5 END INTO return_code
	FROM :path_hash_and_flag
	WHERE conflict_flag = 'W';

	IF :return_code != 0 THEN
		-- log message
	    msg_params_batch = 
	    SELECT A.path_id AS group_id, 0 AS placeholder, from_location AS VALUE
	    FROM :path_hash_and_flag AS A INNER JOIN :paths AS B
	    ON A.path_id = B.external_id
	    WHERE conflict_flag = 'W'
	    UNION ALL
	    SELECT A.path_id AS group_id, 1 AS placeholder, to_location AS VALUE
	    FROM :path_hash_and_flag AS A INNER JOIN :paths AS B
	    ON A.path_id = B.external_id
	    WHERE conflict_flag = 'W';

	    CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_PATH_CONFLICT_WITHIN_LOWER_LAYER', :msg_params_batch, 'W', message);
	    log = SELECT * FROM :message;
	END IF;

	-- fetch cost model id and resource type
	CALL "sap.tm.trp.routing.db.path::p_get_network_attr"(:network_id, :path_usage, cost_model_id, resource_type);

	-- compute path connection measures and path measures
	path_alias = 
	SELECT external_id AS path_id, from_location, to_location
	FROM :paths;
	
	CALL "sap.tm.trp.routing.db.path::p_calculate_path_measures" (:cost_model_id, :resource_type, :path_alias, :path_conn_for_hash, path_measures, path_connection_measures, transport_err_code, transport_err_message, transport_err_log);
	IF :transport_err_code != 0 THEN
	    return_code = 7;
	    message = 
	    SELECT * FROM :transport_err_message;
	    log = 
	    SELECT * FROM :transport_err_log;
	    RETURN;
	END IF;
	
	-- In order to stipulate the rule that sequence start from one and increased by 1 for each connection, generate own sequence
	path_connection_measures = 
	SELECT path_id, ROW_NUMBER() OVER (PARTITION BY path_id ORDER BY sequence) AS sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance,
	transport_duration, transship_duration, transport_cost, transship_cost
	FROM :path_connection_measures;
	
	-- Fetch currency info
   CALL "sap.tm.trp.db.costmodel::sp_cost_model_get"(:cost_model_id, currency_info);
   
   -- CURRENCY CODE MUST EXIST!!!
   SELECT currency_code INTO currency
   FROM :currency_info;

	-- commit delta to db
	id_map = 
	SELECT id AS external_id, "sap.tm.trp.routing.db.path::s_composite_path".NEXTVAL AS id
	FROM :path_measures;

	INSERT INTO "sap.tm.trp.routing.db.path::t_path" ( id, network_model_id, from_location, to_location, total_distance, loading_cost, unloading_cost, total_cost, cost_currency, loading_duration, unloading_duration, total_duration,
			action, source, hash, created_by, created_on, changed_by, changed_on)
	SELECT C.id, :network_id, from_location, to_location, total_distance, loading_cost, unloading_cost, total_cost, :currency, loading_duration, unloading_duration, total_duration,
	:action_create, :manual_source, B.hash, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
	FROM :path_measures AS A INNER JOIN :path_hash AS B ON A.id = B.path_id
	INNER JOIN :id_map AS C ON A.id = C.external_id;

	INSERT INTO "sap.tm.trp.routing.db.path::t_path_sequence" ( path_id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost )
	SELECT B.id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost
	FROM :path_connection_measures AS A INNER JOIN :id_map AS B ON A.path_id = B.external_id
	WHERE A.path_type = :basic_conn_type;

	INSERT INTO "sap.tm.trp.routing.db.path::t_path_sequence" ( path_id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost )
	SELECT B.id, sequence, basic_path_id, path_type, from_location, to_location, from_bp_sequence, to_bp_sequence, mtr, distance, transport_duration, transship_duration, transport_cost, transship_cost
	FROM :path_connection_measures AS A INNER JOIN :id_map AS B ON A.path_id = B.external_id
	WHERE A.path_type = :basic_path_type;
	-- return the id_map
	IF :return_code = 0 THEN
    	msg_params = SELECT 0 AS PLACEHOLDER, network_id AS VALUE FROM DUMMY;
        CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_MANUAL_COMPOSITE_PATH_CREATE_SUCCESS', :msg_params, 'I', message);
        log = SELECT * FROM :message;
    END IF;
    
    -- As required, the return code should be 0 for warning message
    -- Currently only return code 5 is warning message
    IF :return_code = 5 THEN
        return_code = 0;
    END IF;
END