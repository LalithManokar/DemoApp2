PROCEDURE "SAP_TM_ROUTING"."sap.tm.trp.routing.db.path::p_generate_route" (
    IN network_code NVARCHAR(50),
	IN time_range "sap.tm.trp.routing.db.path::tt_time_range",
	IN composite_path_id "sap.tm.trp.routing.db.common::tt_id",
	OUT return_code INTEGER,
	OUT message "sap.tm.trp.routing.db.common::tt_message",
	OUT log "sap.tm.trp.routing.db.common::tt_message"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   DEFAULT SCHEMA "SAP_TM_ROUTING"
   AS 
BEGIN
    /*************************************
       Write your procedure logic 
    *************************************/
    DECLARE network_id BIGINT;
    DECLARE base_network_id BIGINT;
    DECLARE dataset_id BIGINT;
    DECLARE dataset_code NVARCHAR(50);
    DECLARE cost_model_id BIGINT;
    DECLARE setting_group_id BIGINT;
    DECLARE base_resource_type NVARCHAR(50);
    DECLARE cur_time TIMESTAMP;
    DECLARE min_from_time TIMESTAMP; 
    DECLARE max_to_time TIMESTAMP; 
    DECLARE cost_currency NVARCHAR(10);  
    DECLARE network_exist INTEGER;
    DECLARE count INTEGER;
    DECLARE route_usage CONSTANT VARCHAR(50) := 'ROUTE';
    DECLARE CURSOR c_time_range (t_time_range "sap.tm.trp.routing.db.path::tt_time_range")
    FOR SELECT from_time, to_time FROM :t_time_range;
    
    return_code = 0;
    
    message = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
    log = SELECT '' AS severity, '' AS message FROM DUMMY WHERE 1 <> 1;
    
    -- Check network
    SELECT COUNT(*) INTO network_exist FROM "sap.tm.trp.routing.db.path::t_network_model" 
    WHERE code = :network_code;
    IF :network_exist = 0 THEN
        msg_param = SELECT 0 AS PLACEHOLDER, :network_code AS VALUE FROM DUMMY;
        CALL "sap.tm.trp.routing.db.common::p_get_text"('MSG_NETWORK_CODE_NOT_EXIST', 
        :msg_param, 'E', :message);
        log = SELECT * FROM :message;
        return_code = 1;
        RETURN;
    END IF;
	
	SELECT id, dataset_id INTO network_id, dataset_id FROM "sap.tm.trp.routing.db.path::t_network_model"
	WHERE code = :network_code;
	
	SELECT code into dataset_code
	FROM "sap.tm.trp.routing.db.dataset::t_dataset"
	WHERE id = :dataset_id;
	
	-- Check time range
	invalid_time_range = SELECT ROW_NUMBER() OVER () AS id, * FROM :time_range
	WHERE from_time IS NULL OR to_time IS NULL OR from_time > to_time;
	
	SELECT COUNT(*) INTO count FROM :invalid_time_range;
	IF count > 0 THEN
	    msg_params = SELECT id AS group_id, 0 AS placeholder, TO_NVARCHAR(from_time) AS VALUE
	    FROM :invalid_time_range
	    UNION ALL
	    SELECT id AS group_id, 1 AS placeholder, TO_NVARCHAR(to_time) AS VALUE
	    FROM :invalid_time_range;
	    
        CALL "sap.tm.trp.routing.db.common::p_get_text_batch"('MSG_TIME_RANGE_INVALID', 
        :msg_params, 'E', :message);
        
        return_code = 1;
        RETURN;
    END IF;
	
	-- Get location from stack
	CALL "sap.tm.trp.routing.db.path::p_get_network_chain"(:network_id, :network_chain);
	
	locations = SELECT location_id
	FROM "sap.tm.trp.routing.db.dataset::t_dataset_location" AS l
	INNER JOIN "sap.tm.trp.routing.db.dataset::t_dataset" AS d
	ON l.dataset_id = d.id
	INNER JOIN "sap.tm.trp.routing.db.path::t_network_model" AS n
	ON n.dataset_id = d.id
	WHERE n.id IN (SELECT c.id from :network_chain AS c);
	
	CALL "sap.tm.trp.routing.db.path::p_get_network_attr"(:network_id, :route_usage, cost_model_id, base_resource_type);
	
    CALL "sap.tm.trp.db.costmodel::sp_cost_model_get"(:cost_model_id, currency_info);
   
    -- CURRENCY CODE MUST EXIST!!!
    SELECT currency_code INTO cost_currency
    FROM :currency_info;
	
	CALL "sap.tm.trp.routing.db.path::p_get_network_config_info"(:network_id, :route_usage, options);
	
	-- To-do: Check if we should configure the offset
	-- One hour offset
	SELECT ADD_SECONDS(CURRENT_UTCTIMESTAMP, 3600) INTO cur_time FROM DUMMY;

    feasible_time_range = SELECT * FROM :time_range WHERE from_time >= :cur_time;
    
    SELECT MIN(from_time) INTO min_from_time FROM :time_range;
    SELECT MAX(to_time) INTO max_to_time FROM :time_range;
    
    -- Start from current time if it is later than min from time 
    -- and earlier than max to time in the time range
    -- Following two cases will not be considered
    -- Now----|-------|-------|-------|
    -- |-------|-------|-------|----Now
    IF :cur_time > :min_from_time AND :cur_time < :max_to_time THEN
    
        SELECT MIN(from_time) INTO min_from_time FROM :feasible_time_range;
        
        IF :cur_time < :min_from_time THEN
            -- |-------|---Now---|-------|
            feasible_time_range = SELECT :cur_time AS from_time, :min_from_time AS to_time FROM DUMMY
            UNION ALL SELECT * FROM :feasible_time_range;
        ELSE
            -- |-------|-------|---Now---|
            feasible_time_range = SELECT :cur_time AS from_time, :max_to_time AS to_time FROM DUMMY;
        END IF;
    END IF;
    
    time_range_product = SELECT a.from_time, b.to_time
    FROM :feasible_time_range AS a
    INNER JOIN :feasible_time_range AS b
    ON a.from_time < b.to_time;
    
    select * from :feasible_time_range;
    
    SELECT COUNT(*) INTO count FROM :time_range_product;
    
    IF :count > 0 THEN
    
        -- Get merged composite path
        CALL "sap.tm.trp.routing.db.path::p_get_composite_path_merged_view"(
           :network_id,
           '',
           '',
           '',
           merged_path_id,
           conflict_path_id
        );
        
        SELECT COUNT(*) INTO count FROM :composite_path_id;
        
        -- To-do: check validity of composite path id
        IF :count > 0 THEN
            valid_composite_path_id = SELECT id FROM :composite_path_id
            WHERE id IN (SELECT id FROM :merged_path_id);
        ELSE
            valid_composite_path_id = SELECT i.id
            FROM :merged_path_id AS i
            INNER JOIN "sap.tm.trp.routing.db.path::t_path" AS p
            ON i.id = p.id
            WHERE p.network_model_id = :network_id;
        END IF;
        
        SELECT COUNT(*) INTO count FROM :valid_composite_path_id;
        
        IF :count > 0 THEN
        
            -- Delete old routes
            -- If no composite path is specified, generate routes for all composite paths in current layer
            -- To-do: check if we can reuse some route id
            
            route_id_hash = SELECT id, hash FROM "sap.tm.trp.routing.db.path::t_route"
            WHERE network_model_id = :network_id
            AND composite_path_id IN (SELECT id FROM :valid_composite_path_id);
            
            DELETE FROM "sap.tm.trp.routing.db.path::t_route_sequence_capacity"
            WHERE route_id IN (SELECT id FROM :route_id_hash);
            
            DELETE FROM "sap.tm.trp.routing.db.path::t_route_sequence"
            WHERE route_id IN (SELECT id FROM :route_id_hash);
            
            DELETE FROM "sap.tm.trp.routing.db.path::t_route"
            WHERE id IN (SELECT id FROM :route_id_hash);
        	
        	location_pairs = SELECT l1.location_id AS from_location, t.from_time AS dpt_time,
        	l2.location_id AS to_location, t.to_time AS arv_time
        	FROM :locations AS l1, :locations AS l2, :time_range_product t
        	WHERE l1.location_id <> l2.location_id;  
        	
            CALL "sap.tm.trp.routing.db.path::p_build_route_v2"(
        	    :network_id,
        	    :cost_model_id,
        	    :base_resource_type,
        	    :location_pairs,
        	    :valid_composite_path_id,
        	    :options,
        	    route,
        	    route_sequence,
        	    message_tmp,
        	    log_tmp,
        	    return_code
        	); 
        	
        	IF :return_code = 0 THEN
        	
        	    route_header = SELECT route_id, composite_path_id, dpt_time AS departure_time, 
        	    arv_time AS arrival_time FROM :route; 
        	    
        	    route_details = SELECT route_id, sequence, trip_name AS trip_id FROM :route_sequence;
        	    
        	    CALL "sap.tm.trp.routing.db.path::p_calculate_route_hash"(
        	        :route_header, 
        	        :route_details,
        	        route_hash
        	    );
        	    
        	    -- Remove the duplicate from result
        	    -- Just save those not found in database
        	    route_new = SELECT r.*, h.hash FROM :route AS r
        	    INNER JOIN (SELECT hash, FIRST_VALUE(route_id ORDER BY route_id) AS route_id FROM :route_hash GROUP BY hash) AS h
        	    ON r.route_id = h.route_id
        	    WHERE h.hash NOT IN (SELECT DISTINCT hash FROM "sap.tm.trp.routing.db.path::t_route"
        	        WHERE network_model_id IN (SELECT id from :network_chain)
        	    );
        	    
        	    route_id_map_old = SELECT r.route_id, h.id
        	    FROM :route_id_hash h
        	    INNER JOIN :route_new r
        	    ON h.hash = r.hash;
        	    
        	    -- Generate id map
        	    route_id_map_new = SELECT route_id, "sap.tm.trp.routing.db.path::s_route".nextval AS id
        	    FROM (SELECT * FROM :route_new WHERE hash NOT in (SELECT hash FROM :route_id_hash));
        	    
        	    route_id_map = SELECT * FROM :route_id_map_old
        	    UNION ALL SELECT * FROM :route_id_map_new;
        	    
        	    trip_ids = SELECT DISTINCT trip_name AS trip_id, basic_path_id AS path_id FROM :route_sequence;
        	    
        	    CALL "sap.tm.trp.routing.db.dataset::p_query_trip_name"(
        	        :trip_ids, trip_name_map
        	    );
                
                route_sequence_tmp = SELECT * FROM (
                    SELECT route_id, sequence, trip_name AS trip_id, 
                    TO_BIGINT(basic_path_id) AS path_id,
            	    LAG(next_trip_sequence) OVER(ORDER BY sequence) AS from_sequence,
            	    pre_trip_sequence AS to_sequence
            	    FROM :route_sequence)
        	    WHERE from_sequence IS NOT NULL AND to_sequence IS NOT NULL;
        	    
        	    trip_segment = SELECT trip_id, path_id, from_sequence, to_sequence
        	    FROM :route_sequence_tmp;
        	    
        	    -- Cached capacity cannot be used
        	    CALL "sap.tm.trp.routing.db.dataset::p_query_capacity_by_trip_segment"(
        	        :dataset_code, :trip_segment, trip_segment_capacity
        	    );
        	    
        	    route_sequence_capacity =  SELECT route_id, sequence, 'TEU' AS capacity_uom, capacity
        	    FROM :route_sequence_tmp t
        	    INNER JOIN :trip_segment_capacity c
        	    ON t.trip_id = c.trip_id
        	    AND t.from_sequence = c.from_sequence
        	    AND t.to_sequence = c.to_sequence;
        	    
        	    INSERT INTO "sap.tm.trp.routing.db.path::t_route"
        	    (   id, network_model_id, composite_path_id, from_location, to_location, departure_time, 
        	        arrival_time, hash,created_by, created_on, changed_by, changed_on
        	    )
        	    SELECT m.id, :network_id, composite_path_id, st_location, ed_location, dpt_time, arv_time, hash,
        	    SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP, SESSION_CONTEXT('APPLICATIONUSER'), CURRENT_UTCTIMESTAMP
        	    FROM :route_new AS r
        	    INNER JOIN :route_id_map AS m
        	    ON r.route_id = m.route_id;
        	    
        	    INSERT INTO "sap.tm.trp.routing.db.path::t_route_sequence"
        	    (   
        	        route_id, sequence, location, pre_trip_sequence, next_trip_sequence,basic_path_id, path_type,
        	        mtr, trip_id, trip_name, departure_time, arrival_time, distance, storage_cost, handling_cost, transport_cost,
        	        cost_currency, handling_type
        	    )
        	    SELECT m.id, s.sequence, location, pre_trip_sequence, next_trip_sequence,basic_path_id,category,
        	        mtr, s.trip_name AS trip_id, n.trip_name, dpt_time, arv_time, distance, storage_cost, handling_cost, transport_cost,
        	        :cost_currency, act_type
        	    FROM :route_sequence AS s
        	    INNER JOIN :route_id_map AS m
        	    ON s.route_id = m.route_id
        	    LEFT OUTER JOIN :trip_name_map AS n
        	    ON s.trip_name = n.trip_id;
        	    
        	    INSERT INTO "sap.tm.trp.routing.db.path::t_route_sequence_capacity"
        	    (   
        	        route_id, sequence, capacity, capacity_uom
        	    )
        	    SELECT m.id, c.sequence, c.capacity, c.capacity_uom
        	    FROM :route_sequence_capacity AS c
        	    INNER JOIN :route_id_map AS m
        	    ON c.route_id = m.route_id;
        	    
        	    message = SELECT * FROM :message 
                UNION ALL SELECT * FROM :message_tmp;
                log = SELECT * FROM :log 
                UNION ALL SELECT * FROM :log_tmp;
        	ELSE 
                message = SELECT * FROM :message_tmp;
                log = SELECT * FROM :log_tmp;
                RETURN;
        	END IF;
        END IF;
	END IF;

END;