PROCEDURE "SAP_TM_TRP"."sap.tm.trp.db.costmodel.storagecost::p_get_settlement_stock" (
	IN COST_DATASET "sap.tm.trp.db.costmodel.storagecost::tt_matched_cost_dataset",
	IN SUPPLY_DEMAND "sap.tm.trp.db.costmodel.storagecost::tt_sd_result",
	IN RESOURCE_TYPE_TEU "sap.tm.trp.db.costmodel.storagecost::tt_resource_type_teu",
	OUT SETTLEMENT_STOCK "sap.tm.trp.db.costmodel.storagecost::tt_settlement_stock"
 ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	DEFAULT SCHEMA "SAP_TM_TRP"   
	 AS
BEGIN

   DECLARE START_TIME TIMESTAMP;
   DECLARE END_TIME TIMESTAMP;
   DECLARE MAX_VALID_TIME TIMESTAMP DEFAULT '9999-12-31 23:59:59.9999999';
   
	SELECT MIN(START_TIME) AS MIN_START_TIME,MAX(END_TIME) AS MAX_END_TIME
	INTO  START_TIME,END_TIME
	FROM :SUPPLY_DEMAND;
	
    -- prepare stock data
	SUPPLY_DEMAND_STOCK = SELECT ROW_NUMBER() OVER(PARTITION BY LOCATION, RESOURCE_TYPE) AS SEQ, *, GREATEST(SUPPLY + STOCK - DEMAND,0) AS SUPPLY_DEMAND FROM :SUPPLY_DEMAND;
	
	SUPPLY_DEMAND_STOCK_WITH_PREVIOUS = SELECT 
		T1.LOCATION,
		T1.RESOURCE_TYPE,
		T1.START_TIME,
		T1.END_TIME,
		T1.STOCK + T2.SUPPLY_DEMAND AS PREVIOUS_STOCK,
		T1.SUPPLY_DEMAND AS STOCK,
		(T1.SUPPLY_DEMAND - (T1.STOCK + T2.SUPPLY_DEMAND)) / (SECONDS_BETWEEN(T1.START_TIME,T1.END_TIME) / 3600) AS GROWTH_IN_HOUR
	FROM :SUPPLY_DEMAND_STOCK T1
	LEFT JOIN :SUPPLY_DEMAND_STOCK T2
	ON T1.LOCATION = T2.LOCATION AND T1.RESOURCE_TYPE = T2.RESOURCE_TYPE AND T1.SEQ = T2.SEQ + 1
	WHERE T1.SEQ > 1;
	
     -- Treat different free pool type seperately due to the different handling of them and union them up at last  
     
     --Get the refresh date list of monthly between start time and end time:
     MONTHLY_SETTLEMENT_TIME_INFO =
         SELECT  T1.LOCATION,T1.RESOURCE_TYPE, T0.DATETIMESTAMP AS SETTLEMENT_TIME  
         FROM :COST_DATASET T1, "_SYS_BI"."M_TIME_DIMENSION" T0
         WHERE T1.TYPE = 'QUANTITY' AND T1.FREE_POOL_TYPE = 'MONTHLY' AND (T0.DATETIMESTAMP BETWEEN :START_TIME AND :END_TIME) AND T1.START_AT = T0.DAY_INT; 
   
     --Get the refresh date list of weekly between start time and end time:
     WEEKLY_SETTLEMENT_TIME_INFO = 
         SELECT  T1.LOCATION,T1.RESOURCE_TYPE, T0.DATETIMESTAMP AS SETTLEMENT_TIME   
         FROM :COST_DATASET T1, "_SYS_BI"."M_TIME_DIMENSION" T0      
         WHERE T1.TYPE = 'QUANTITY' AND T1.FREE_POOL_TYPE = 'WEEKLY' AND (T0.DATETIMESTAMP BETWEEN :START_TIME AND :END_TIME) AND T1.START_AT = T0.DAY_OF_WEEK_INT + 1;
       
     --Get the refresh date list of daily between start time and end time:
     DAILY_SETTLEMENT_TIME_INFO = 
         SELECT  T1.LOCATION,T1.RESOURCE_TYPE, T0.DATETIMESTAMP AS SETTLEMENT_TIME   
         FROM :COST_DATASET T1, "_SYS_BI"."M_TIME_DIMENSION" T0      
         WHERE T1.TYPE = 'QUANTITY' AND T1.FREE_POOL_TYPE = 'DAILY' AND T0.DATETIMESTAMP BETWEEN :START_TIME AND :END_TIME;      
   
     -- The free pool time table, need to append the previous refresh date before the window start
     SETTLEMENT_TIME_LIST =
         SELECT ROW_NUMBER() OVER(PARTITION BY LOCATION, RESOURCE_TYPE) AS SEQ, * FROM (
         	SELECT * FROM (
		         SELECT * FROM :MONTHLY_SETTLEMENT_TIME_INFO
		         UNION 
		         SELECT * FROM :WEEKLY_SETTLEMENT_TIME_INFO                    
		         UNION 
		         SELECT * FROM :DAILY_SETTLEMENT_TIME_INFO
		         UNION                     
		         SELECT LOCATION, RESOURCE_TYPE, ADD_MONTHS(FIRST_SETTLEMENT_TIME, -1) AS SETTLEMENT_TIME FROM  
		         ( SELECT LOCATION, RESOURCE_TYPE, MIN(SETTLEMENT_TIME) AS FIRST_SETTLEMENT_TIME
		           FROM :MONTHLY_SETTLEMENT_TIME_INFO
		           GROUP BY LOCATION, RESOURCE_TYPE  
		         )
		         UNION
		         SELECT LOCATION, RESOURCE_TYPE, ADD_DAYS(FIRST_SETTLEMENT_TIME, -7) AS SETTLEMENT_TIME FROM  
		         ( SELECT LOCATION, RESOURCE_TYPE, MIN(SETTLEMENT_TIME) AS FIRST_SETTLEMENT_TIME
		           FROM :WEEKLY_SETTLEMENT_TIME_INFO
		           GROUP BY LOCATION, RESOURCE_TYPE  
		         )
		         UNION                     
		         SELECT LOCATION, RESOURCE_TYPE, ADD_DAYS(FIRST_SETTLEMENT_TIME, -1) AS SETTLEMENT_TIME FROM  
		         ( SELECT LOCATION, RESOURCE_TYPE, MIN(SETTLEMENT_TIME) AS FIRST_SETTLEMENT_TIME
		           FROM :DAILY_SETTLEMENT_TIME_INFO
		           GROUP BY LOCATION, RESOURCE_TYPE  
		         )
	         ) ORDER BY LOCATION,RESOURCE_TYPE,SETTLEMENT_TIME
         );
	
	-- First settlement time stock equal start time stock
	FIRST_SETTLEMENT_STOCK = SELECT 
		T1.LOCATION,
		T1.RESOURCE_TYPE,
		T1.SETTLEMENT_TIME,
		T2.STOCK
	FROM :SETTLEMENT_TIME_LIST T1
	INNER JOIN :SUPPLY_DEMAND_STOCK T2
	ON T1.LOCATION = T2.LOCATION AND T1.RESOURCE_TYPE = T2.RESOURCE_TYPE AND T2.START_TIME = :START_TIME
	WHERE T1.SETTLEMENT_TIME < :START_TIME;
	
	-- get other settlement time list
	OTHER_SETTLEMENT_TIME_LIST = SELECT T1.LOCATION,T1.RESOURCE_TYPE,T2.SETTLEMENT_TIME AS PREVIOUS_SETTLEMENT_TIME,T1.SETTLEMENT_TIME
	FROM :SETTLEMENT_TIME_LIST T1
	INNER JOIN :SETTLEMENT_TIME_LIST T2
	ON T1.LOCATION = T2.LOCATION AND T1.RESOURCE_TYPE = T2.RESOURCE_TYPE AND T1.SEQ = T2.SEQ + 1
	WHERE T1.SEQ > 1;
	
	OTHER_SETTLEMENT_STOCK = SELECT 
		T1.LOCATION,
		T1.RESOURCE_TYPE,
		T1.PREVIOUS_SETTLEMENT_TIME,
		T1.SETTLEMENT_TIME,
		T2.START_TIME,
		T2.END_TIME,
		T2.PREVIOUS_STOCK,
		T2.STOCK,
		T2.GROWTH_IN_HOUR,
		CASE T1.SETTLEMENT_TIME
		WHEN T2.START_TIME THEN T2.PREVIOUS_STOCK
		WHEN T2.END_TIME THEN T2.STOCK
		ELSE T2.PREVIOUS_STOCK + (SECONDS_BETWEEN(T2.START_TIME,T1.SETTLEMENT_TIME) / 3600) * T2.GROWTH_IN_HOUR
		END AS SETTLEMENT_STOCK
	FROM :OTHER_SETTLEMENT_TIME_LIST T1
	INNER JOIN :SUPPLY_DEMAND_STOCK_WITH_PREVIOUS T2
	ON T1.LOCATION = T2.LOCATION AND T1.RESOURCE_TYPE = T2.RESOURCE_TYPE
	AND T1.SETTLEMENT_TIME BETWEEN T2.START_TIME AND T2.END_TIME
	ORDER BY T1.LOCATION, T1.RESOURCE_TYPE, T1.PREVIOUS_SETTLEMENT_TIME;

	-- SETTLEMENT_STOCK = SELECT NULL AS LOCATION,NULL AS RESOURCE_TYPE,NULL AS SETTLEMENT_TIME,NULL AS STOCK FROM DUMMY;
	SETTLEMENT_STOCK_PCS = 
	SELECT * FROM (
	SELECT * FROM :FIRST_SETTLEMENT_STOCK
	UNION
	SELECT LOCATION,RESOURCE_TYPE,SETTLEMENT_TIME, AVG(SETTLEMENT_STOCK) AS STOCK FROM :OTHER_SETTLEMENT_STOCK GROUP BY LOCATION,RESOURCE_TYPE,SETTLEMENT_TIME
	) ORDER BY LOCATION,RESOURCE_TYPE,SETTLEMENT_TIME;
	
	SETTLEMENT_STOCK_TEU = 
	SELECT LOCATION,'*' AS RESOURCE_TYPE,SETTLEMENT_TIME,SUM(STOCK*T2.TEU) AS STOCK 
	FROM :SETTLEMENT_STOCK_PCS T1
	LEFT JOIN :RESOURCE_TYPE_TEU T2 ON T1.RESOURCE_TYPE = T2.RESOURCE_TYPE
	GROUP BY LOCATION,SETTLEMENT_TIME;
	
	SETTLEMENT_STOCK_RESULT = SELECT 
	ROW_NUMBER() OVER(PARTITION BY LOCATION, RESOURCE_TYPE ORDER BY SETTLEMENT_TIME) AS SEQ, * 
	FROM(
		SELECT * FROM :SETTLEMENT_STOCK_PCS
		UNION
		SELECT * FROM :SETTLEMENT_STOCK_TEU
	)
	ORDER BY LOCATION, RESOURCE_TYPE, SEQ;

	SETTLEMENT_STOCK = SELECT 
	T1.LOCATION, T1.RESOURCE_TYPE, T1.SETTLEMENT_TIME, IFNULL(T2.SETTLEMENT_TIME, :MAX_VALID_TIME) AS VALID_TO, T1.STOCK
	FROM :SETTLEMENT_STOCK_RESULT T1
	LEFT JOIN :SETTLEMENT_STOCK_RESULT T2 ON T1.SEQ + 1 = T2.SEQ AND T1.LOCATION = T2.LOCATION AND T1.RESOURCE_TYPE = T2.RESOURCE_TYPE;
	
	
	
	-- Useless code, to resolve compilation errors
	SELECT * FROM :SETTLEMENT_TIME_LIST;
	
END;