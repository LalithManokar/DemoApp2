PROCEDURE "SAP_TM_TRP"."sap.tm.trp.db.pipeline::p_get_bubble_on_map_for_template_plan"(
	IN PLAN_ID BIGINT,
	IN TIMEZONE NVARCHAR(50),
    IN IN_EXECUTION_ID BIGINT,
    IN IN_NODE_ID BIGINT,
    IN SEQUENCE BIGINT,
    IN IN_POLYGON CLOB,
    OUT out_bubble_on_map "sap.tm.trp.db.pipeline::tt_bubble_on_map",
    OUT TOO_MUCH_LOCATION_FLAG SMALLINT,
    OUT GIS_TYPE VARCHAR(10),
    OUT OUT_PLAN_STATUS SMALLINT,
    OUT OUT_LOCATIONS_XPOS_YPOS_INVALID  "sap.tm.trp.db.pipeline::tt_location_info_list" 
)
    LANGUAGE SQLSCRIPT
    SQL SECURITY INVOKER 
    DEFAULT SCHEMA "SAP_TM_TRP"
    AS
BEGIN
 

        DECLARE LOCATION_FILTER_TYPE INTEGER;
	    /*DECLARE LOCATION_TYPE INTEGER := 1;
	    DECLARE LOCATION_GROUP_TYPE INTEGER :=2 ;
	    DECLARE ZONE_TYPE  INTEGER :=3 ;
	    DECLARE ZONE_GROUP_TYPE  INTEGER := 4;
	    DECLARE REGION_TYPE INTEGER :=5 ;
	    DECLARE REGION_GROUP_TYPE INTEGER :=6 ;*/
	    DECLARE ID_COUNT INTEGER;
	    --DECLARE OUT_UUID VARCHAR(32) :=SYSUUID ; 
	    DECLARE MAX_LOCATION_NUM_ON_MAP INTEGER :=2000;
	    DECLARE VAR_LOCATION_NUM INTEGER :=0 ; 
	    --DECLARE GIS_TYPE_POINT VARCHAR(10) := 'POINT';
	   -- DECLARE GIS_TYPE_POLYGON VARCHAR(10) := 'POLYGON'; 
 		--DECLARE VAR_PLAN_STATUS SMALLINT :=0 ;
	    --DECLARE PLAN_STATUS_SUSPEND SMALLINT := 1;
	    OUT_PLAN_STATUS := -1;--this output do not need any more according to the new requirements(show history table view ), keep it just in order to keep the interface not changed.Will remove it later. 
	
	
	    TOO_MUCH_LOCATION_FLAG :=0;
	    GIS_TYPE := ''; 
	    
	    /*
	     --Check if the status of the plan = 1 (suspend), if it is, then abandon follwoing process.
	    SQL_PLAN_STATUS =
	    SELECT T1.STATUS 
	    FROM "sap.tm.trp.db.pipeline::t_plan_model" T1
	    INNER JOIN "sap.tm.trp.db.pipeline::t_plan_execution" T2 ON (T1.ID = T2.PLAN_MODEL_ID)
	    WHERE T2.ID = :IN_EXECUTION_ID;
	    
	    SELECT COUNT(1) INTO ID_COUNT
	    FROM :SQL_PLAN_STATUS;
	    
	    IF ID_COUNT >0 THEN
	      SELECT STATUS INTO VAR_PLAN_STATUS FROM :SQL_PLAN_STATUS;
	      OUT_PLAN_STATUS := :VAR_PLAN_STATUS;
	      IF VAR_PLAN_STATUS = :PLAN_STATUS_SUSPEND THEN
	         RETURN;
	      END IF;
	    END IF;
	    */
	    
     CALL "sap.tm.trp.db.pipeline::p_get_execution_result_by_executionid_base_on_map_for_bubble"(:PLAN_ID,:TIMEZONE,:IN_EXECUTION_ID,:IN_NODE_ID,:SEQUENCE,'N/A',AGG_LOCATION_ALERT_INFO);
     
     
	   
	   SQL0 = SELECT TOP 1 LOCATION_FILTER_TYPE FROM :AGG_LOCATION_ALERT_INFO ;
	   /*
       SQL0 = SELECT TOP 1 VALUE
                FROM "sap.tm.trp.db.pipeline::t_execution_context"
                WHERE EXECUTION_ID = :IN_EXECUTION_ID
                      AND KEY = 'LOCATION_FILTER_TYPE';
                      */
                      
	      
	     SELECT COUNT(1) INTO ID_COUNT
	     FROM :SQL0;
	      
	     IF(ID_COUNT !=0 ) THEN
	           SELECT LOCATION_FILTER_TYPE INTO LOCATION_FILTER_TYPE
              FROM :SQL0;
	      ELSE
	         LOCATION_FILTER_TYPE := 0;
	         out_alert_on_map = SELECT NULL AS LOCATION_ID,NULL AS LOCATION_NAME,NULL AS LATITUDE,NULL AS LONGITUDE,
                  NULL AS BOUNDARY,NULL AS ALERT_NUM,NULL AS ALERT_SCORE,NULL AS OUTPUT_KEY,NULL AS OUTPUT_VALUE,NULL AS POINT_TYPE
	              FROM DUMMY;
	          TOO_MUCH_LOCATION_FLAG := 0;
	         RETURN;
	      END IF;
	    
	  IN_LOCATION_IDS_SQL = SELECT DISTINCT LOCATION_ID AS ID FROM :AGG_LOCATION_ALERT_INFO;
	 
	   CALL "sap.tm.trp.db.pipeline::p_get_xpos_or_polygon_info_for_location"(:IN_LOCATION_IDS_SQL,:LOCATION_FILTER_TYPE,:IN_POLYGON,OUT_GEO_POLYGON_INFO_SQL,GIS_TYPE,OUT_LOCATIONS_XPOS_YPOS_INVALID);
     
       SELECT COUNT(1) AS LOCATION_NUM INTO VAR_LOCATION_NUM
	  FROM :OUT_GEO_POLYGON_INFO_SQL;
	  
	  IF VAR_LOCATION_NUM > :MAX_LOCATION_NUM_ON_MAP THEN
	    out_bubble_on_map = SELECT NULL AS LOCATION_ID,NULL AS LOCATION_NAME,NULL AS LATITUDE,NULL AS LONGITUDE,
                  NULL AS BOUNDARY,NULL AS ALERT_NUM,NULL AS ALERT_SCORE,
                  NULL AS MESSAGE,NULL AS SURPLUS_DEFICIT_NUM,NULL AS THRESHOLD,
	        NULL AS SURPLUS_DEFICIT_PERCENT,
                  NULL AS OUTPUT_KEY,NULL AS OUTPUT_VALUE,NULL AS POINT_TYPE,NULL AS OUTPUT_NODE_NAME
	              FROM DUMMY;
	    TOO_MUCH_LOCATION_FLAG := 1;
	END IF;
	
	/*
	out_bubble_on_map = SELECT DISTINCT LOCATION_ID,LOCATION_NAME,XPOS AS LATITUDE,YPOS AS LONGITUDE,BOUNDARY,
	ALERT_NUM,ALERT_SCORE,
	 MESSAGE,SURPLUS_DEFICIT_NUM,THRESHOLD,
	        SURPLUS_DEFICIT_PERCENT,
	        OUTPUT_KEY,OUTPUT_VALUE,POINT_TYPE,NULL AS OUTPUT_NODE_NAME
	FROM :temp_alert_info_on_map;
	SELECT COUNT(1) AS LOCATION_NUM INTO VAR_LOCATION_NUM
	FROM :out_bubble_on_map;
	*/
	
-- 	Re-generate those 0 number records not saved in db
	
	agg_info_with_zero_records = SELECT LOCATION_ID, LOCATION_NAME,LOCATION_FILTER_TYPE,
        CASE  WHEN OUTPUT_KEY = 'DEMAND' 
        	      THEN 'SUPPLY' 
            ELSE 'DEMAND' END  AS OUTPUT_KEY,
            0                  AS OUTPUT_VALUE,
        ALERT_NUM,ALERT_SCORE,MESSAGE,SURPLUS_DEFICIT_NUM,THRESHOLD,SURPLUS_DEFICIT_PERCENT
        FROM :AGG_LOCATION_ALERT_INFO
        UNION ALL
        SELECT LOCATION_ID, LOCATION_NAME,LOCATION_FILTER_TYPE,OUTPUT_KEY,OUTPUT_VALUE,ALERT_NUM,
        ALERT_SCORE,MESSAGE,SURPLUS_DEFICIT_NUM,THRESHOLD,
        SURPLUS_DEFICIT_PERCENT
        FROM :AGG_LOCATION_ALERT_INFO ;
    
    agg_info_with_zero_records = SELECT LOCATION_ID, LOCATION_NAME,LOCATION_FILTER_TYPE,OUTPUT_KEY,SUM(OUTPUT_VALUE) AS OUTPUT_VALUE,ALERT_NUM,
        ALERT_SCORE,MESSAGE,SURPLUS_DEFICIT_NUM,THRESHOLD,
        SURPLUS_DEFICIT_PERCENT
        FROM :agg_info_with_zero_records
        GROUP BY LOCATION_ID, LOCATION_NAME,LOCATION_FILTER_TYPE,OUTPUT_KEY,ALERT_NUM,
        ALERT_SCORE,MESSAGE,SURPLUS_DEFICIT_NUM,THRESHOLD,
        SURPLUS_DEFICIT_PERCENT;
	
	out_bubble_on_map = SELECT T1.LOCATION_ID,T1.LOCATION_NAME,T2.XPOS AS LATITUDE,T2.YPOS AS LONGITUDE
	,T2.BOUNDARY,T1.ALERT_NUM,T1.ALERT_SCORE,T1.MESSAGE,T1.SURPLUS_DEFICIT_NUM,T1.THRESHOLD,T1.SURPLUS_DEFICIT_PERCENT,
	T1.OUTPUT_KEY,T1.OUTPUT_VALUE,
	T2.POINT_TYPE,NULL AS OUTPUT_NODE_NAME
	FROM :agg_info_with_zero_records T1
	INNER JOIN :OUT_GEO_POLYGON_INFO_SQL T2 ON (T1.LOCATION_ID = T2.LOCATION_ID);
	
     
   
   
END;